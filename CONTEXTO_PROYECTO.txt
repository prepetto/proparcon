RESUMEN DE CONTEXTO: PROPARCON (API & WEB)
============================================================


=== ESTRUCTURA BACKEND (FastAPI) ===


--- ARCHIVO: alembic.ini ---
# A generic, single database configuration.

[alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = %(here)s/alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.  for multiple paths, the path separator
# is defined by "path_separator" below.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the tzdata library which can be installed by adding
# `alembic[tz]` to the pip requirements.
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to <script_location>/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "path_separator"
# below.
# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions

# path_separator; This indicates what character is used to split lists of file
# paths, including version_locations and prepend_sys_path within configparser
# files such as alembic.ini.
# The default rendered in new alembic.ini files is "os", which uses os.pathsep
# to provide os-dependent path splitting.
#
# Note that in order to support legacy alembic.ini files, this default does NOT
# take place if path_separator is not present in alembic.ini.  If this
# option is omitted entirely, fallback logic is as follows:
#
# 1. Parsing of the version_locations option falls back to using the legacy
#    "version_path_separator" key, which if absent then falls back to the legacy
#    behavior of splitting on spaces and/or commas.
# 2. Parsing of the prepend_sys_path option falls back to the legacy
#    behavior of splitting on spaces, commas, or colons.
#
# Valid values for path_separator are:
#
# path_separator = :
# path_separator = ;
# path_separator = space
# path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
path_separator = os


# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

# database URL.  This is consumed by the user-maintained env.py script only.
# other means of configuring database URLs may be customized within the env.py
# file.
sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# hooks = ruff
# ruff.type = module
# ruff.module = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Alternatively, use the exec runner to execute a binary found on your PATH
# hooks = ruff
# ruff.type = exec
# ruff.executable = ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration.  This is also consumed by the user-maintained
# env.py script only.
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


--- ARCHIVO: alembic\env.py ---
"""
alembic/env.py

Propósito:
- Ejecutar migraciones Alembic usando SQLAlchemy Async Engine.
- Forzar el uso del esquema configurado (POSTGRES_SCHEMA) para objetos y alembic_version.
- Asegurar que el search_path incluya el esquema y public.
- Evitar fallos de Alembic/configparser cuando la URL contiene caracteres '%' (por ejemplo en passwords).
"""

import asyncio
import os
import sys
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import async_engine_from_config

# --- 1) Agregar el directorio raíz al PATH para encontrar 'app' ---
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

# --- 2) Importar Settings y Modelos para que Alembic detecte metadata ---
from app.core.settings import settings
from app.models.base import Base
from app.models.users import User  # noqa: F401  (import requerido para autogenerate)

# --- 3) Configuración base de Alembic ---
config = context.config

# Configurar logging desde alembic.ini si existe
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Metadata objetivo de SQLAlchemy
target_metadata = Base.metadata

# --- 4) Sobrescribir la URL de BD con la configurada por Settings (.env / variables entorno) ---
# Nota crítica:
# Alembic usa configparser internamente; configparser interpreta '%' como interpolación.
# Si la contraseña (u otra parte de la URL) contiene '%', Alembic lanza ValueError.
# Solución: escapar '%' -> '%%' SOLO para Alembic.
safe_url = settings.database_url_async.replace("%", "%%")
config.set_main_option("sqlalchemy.url", safe_url)


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        version_table_schema=settings.POSTGRES_SCHEMA if settings.POSTGRES_SCHEMA else None,
        include_schemas=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection) -> None:
    """Configura el contexto y ejecuta migraciones en modo online (con conexión ya abierta)."""
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        version_table_schema=settings.POSTGRES_SCHEMA if settings.POSTGRES_SCHEMA else None,
        include_schemas=True,
    )

    with context.begin_transaction():
        # Antes de migrar, aseguramos que el search_path incluya el esquema
        if settings.POSTGRES_SCHEMA:
            connection.exec_driver_sql(
                f"SET search_path TO {settings.POSTGRES_SCHEMA}, public"
            )
        context.run_migrations()


async def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
# --- Fin de alembic/env.py ---

--- ARCHIVO: alembic\versions\23669b8791dc_v1_baseline_proparcon_schema.py ---
"""v1_baseline_proparcon_schema
Revision ID: [MANTÉN EL ID GENERADO]
Revises: 
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import text

revision: str = '23669b8791dc'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    conn = op.get_bind()
    
    # 1. Crear Esquema
    conn.execute(text("CREATE SCHEMA IF NOT EXISTS proparcon;"))

    # 2. Bloque de Secuencias (Basado en tu DDL)
    # He incluido las principales, añade las demás siguiendo el patrón
    sequences = [
        "CREATE SEQUENCE IF NOT EXISTS proparcon.persona_id_seq;",
        "CREATE SEQUENCE IF NOT EXISTS proparcon.inmueble_id_seq;",
        "CREATE SEQUENCE IF NOT EXISTS proparcon.users_id_seq;"
    ]
    for seq in sequences:
        conn.execute(text(seq))

    # 3. Bloque de Tablas (Ordenado por dependencias)
    tables = [
        # Catálogos primero
        "CREATE TABLE IF NOT EXISTS proparcon.cat_pais (id int4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, iso2 bpchar(2) NOT NULL UNIQUE, nombre text NOT NULL);",
        "CREATE TABLE IF NOT EXISTS proparcon.cat_tipo_inmueble (id int4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, codigo varchar(40) NOT NULL UNIQUE, descripcion text NOT NULL);",
        "CREATE TABLE IF NOT EXISTS proparcon.cat_rol (id int4 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, codigo varchar(40) NOT NULL UNIQUE, descripcion text NOT NULL);",
        
        # Entidades Core
        "CREATE TABLE IF NOT EXISTS proparcon.direccion (id int8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, via_nombre text NOT NULL, numero varchar(10), cp varchar(10));",
        "CREATE TABLE IF NOT EXISTS proparcon.persona (id int8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, tipo_doc varchar(20) NOT NULL, doc_identidad text NOT NULL UNIQUE, nombre text NOT NULL, apellido1 text NOT NULL, direccion_id int8 REFERENCES proparcon.direccion(id));",
        "CREATE TABLE IF NOT EXISTS proparcon.inmueble (id int8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, tipo_inmueble_id int4 REFERENCES proparcon.cat_tipo_inmueble(id), nombre_publico text, direccion_id int8 REFERENCES proparcon.direccion(id));",
        "CREATE TABLE IF NOT EXISTS proparcon.inmueble_propiedad (id int8 GENERATED ALWAYS AS IDENTITY PRIMARY KEY, inmueble_id int8 REFERENCES proparcon.inmueble(id) ON DELETE CASCADE, persona_id int8 REFERENCES proparcon.persona(id), porcentaje numeric(5,2) CHECK (porcentaje >= 0 AND porcentaje <= 100));",
        
        # Tabla Users (Sincronizada con tu app.models.users)
        "CREATE TABLE IF NOT EXISTS proparcon.users (id varchar(50) DEFAULT nextval('proparcon.users_id_seq') PRIMARY KEY, persona_id int8 UNIQUE REFERENCES proparcon.persona(id), email varchar(255) UNIQUE NOT NULL, password_hash varchar(255) NOT NULL, role varchar(20) DEFAULT 'lector');"
    ]
    for table in tables:
        conn.execute(text(table))

    # 4. Funciones y Triggers (Tu lógica de integridad)
    logic = [
        """
        CREATE OR REPLACE FUNCTION proparcon.trg_check_propiedades_100()
        RETURNS trigger LANGUAGE plpgsql AS $$
        DECLARE v_sum_pleno numeric(7,2);
        BEGIN
          SELECT COALESCE(SUM(porcentaje),0) INTO v_sum_pleno FROM proparcon.inmueble_propiedad WHERE inmueble_id = NEW.inmueble_id;
          IF v_sum_pleno > 100 THEN RAISE EXCEPTION 'Excede 100%%'; END IF;
          RETURN NEW;
        END; $$;
        """,
        "DROP TRIGGER IF EXISTS trg_propiedades_100 ON proparcon.inmueble_propiedad;",
        "CREATE TRIGGER trg_propiedades_100 AFTER INSERT OR UPDATE ON proparcon.inmueble_propiedad FOR EACH ROW EXECUTE FUNCTION proparcon.trg_check_propiedades_100();"
    ]
    for item in logic:
        conn.execute(text(item))

def downgrade() -> None:
    op.execute(text("DROP SCHEMA IF EXISTS proparcon CASCADE;"))

--- ARCHIVO: alembic\versions\4d704a5130b7_fix_users_id_to_bigint_identity.py ---
"""
Revision: 4d704a5130b7 - fix users.id to BIGINT IDENTITY

Objetivo:
- Corregir inconsistencia del baseline donde `proparcon.users.id` es varchar con nextval().
- Dejar `users.id` como BIGINT GENERATED ALWAYS AS IDENTITY y mantener PK.
- Eliminar dependencia del default nextval sobre una secuencia externa.

Notas operativas:
- Esta migración es segura si los valores existentes en users.id son numéricos (aunque estén como texto).
- Si existieran FKs hacia proparcon.users(id), habría que migrarlos también.
"""

from alembic import op

# revision identifiers, used by Alembic.
revision = "4d704a5130b7"
down_revision = "23669b8791dc"
branch_labels = None
depends_on = None


def upgrade() -> None:
    """
    1) Quitar default de nextval (si existe).
    2) Convertir id de varchar -> bigint.
    3) Activar IDENTITY en la columna.
    4) Eliminar secuencia antigua (si existe) para evitar residuos.
    """
    # 1) Quitar default si venía de nextval
    op.execute("ALTER TABLE proparcon.users ALTER COLUMN id DROP DEFAULT")

    # 2) Convertir a BIGINT (fallará si hay valores no numéricos)
    op.execute(
        "ALTER TABLE proparcon.users "
        "ALTER COLUMN id TYPE BIGINT USING (NULLIF(id,'')::BIGINT)"
    )

    # 3) Activar identity
    op.execute(
        "ALTER TABLE proparcon.users "
        "ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY"
    )

    # 4) Limpiar secuencia antigua si existe
    op.execute("DROP SEQUENCE IF EXISTS proparcon.users_id_seq")


def downgrade() -> None:
    """
    Reversión:
    1) Quitar identity.
    2) Volver id a varchar.
    3) Recrear secuencia y default nextval como estaba en el baseline.
    """
    op.execute(
        "ALTER TABLE proparcon.users "
        "ALTER COLUMN id DROP IDENTITY IF EXISTS"
    )

    op.execute(
        "ALTER TABLE proparcon.users "
        "ALTER COLUMN id TYPE VARCHAR(50) USING id::VARCHAR(50)"
    )

    op.execute("CREATE SEQUENCE IF NOT EXISTS proparcon.users_id_seq")
    op.execute(
        "ALTER TABLE proparcon.users "
        "ALTER COLUMN id SET DEFAULT nextval('proparcon.users_id_seq')"
    )


--- ARCHIVO: app\main.py ---
"""
====================================================================
ARCHIVO: app/main.py
PROYECTO: PROPARCON API
====================================================================

OBJETIVO:
- Definir la instancia principal de FastAPI.
- Configurar middlewares globales (slash, CORS).
- Registrar routers versionados y funcionales.

DECISIONES DE DISEÑO:
- Auth SOLO va versionado (/v1/auth).
- El dominio funcional se expone bajo /api/* mediante agregador.
- Se evita cualquier redirección automática de slash.
====================================================================
"""

import logging

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware

# -------------------------------------------------------------------
# SECCIÓN 0: LOGGING BÁSICO
# -------------------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logger = logging.getLogger(__name__)

# -------------------------------------------------------------------
# SECCIÓN 1: INSTANCIA DE LA API
# -------------------------------------------------------------------
app = FastAPI(
    title="PROPARCON API",
    version="1.4.0",
    redirect_slashes=False,  # Evita 307/405 por trailing slash
)

logger.info("Inicializando PROPARCON API")

# -------------------------------------------------------------------
# SECCIÓN 2: MIDDLEWARE - NORMALIZACIÓN DE SLASH FINAL
# -------------------------------------------------------------------
@app.middleware("http")
async def remove_trailing_slash(request: Request, call_next):
    """
    Normaliza rutas con barra final:
        /api/persona/  -> /api/persona

    Evita redirecciones automáticas que rompen clientes web estrictos.
    """
    path = request.url.path
    if path != "/" and path.endswith("/"):
        request.scope["path"] = path.rstrip("/")
    return await call_next(request)

# -------------------------------------------------------------------
# SECCIÓN 3: CORS
# -------------------------------------------------------------------
# IMPORTANTE:
# allow_origins=["*"] es SOLO aceptable en desarrollo.
# En producción debe limitarse al dominio del frontend.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # DEV ONLY
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# -------------------------------------------------------------------
# SECCIÓN 4: REGISTRO DE ROUTERS
# -------------------------------------------------------------------
# 4.1 Auth versionado
from app.api.v1.endpoints import auth as auth_v1

app.include_router(
    auth_v1.router,
    prefix="/v1/auth",
    tags=["Auth"],
)

# 4.2 API funcional (dominio) bajo /api
from app.routers.api import api_router

app.include_router(
    api_router,
    prefix="/api",
)

# -------------------------------------------------------------------
# SECCIÓN 5: ENDPOINTS DE SISTEMA
# -------------------------------------------------------------------
@app.get("/health", tags=["Sistema"])
async def health():
    """
    Healthcheck simple para balanceadores y monitorización.
    """
    return {
        "status": "ok",
        "service": "proparcon-api",
        "mode": "no-slash-strict",
    }


--- ARCHIVO: app\api\catalogos copy.py ---
"""
====================================================================
ARCHIVO: app/api/catalogos.py
PROYECTO: PROPARCON API
====================================================================

Objetivo:
  - CRUD genérico para catálogos del esquema PROPARCON.
  - Alineado con colección Postman "PROPARCON · Catálogos V1 (CRUD)".

Rutas:
  - GET    /api/catalogos/{catalogo}                  (LIST)
  - GET    /api/catalogos/{catalogo}/{item_id}        (GET BY ID)
  - POST   /api/catalogos/{catalogo}                  (CREATE)
  - PATCH  /api/catalogos/{catalogo}/{item_id}        (PARTIAL UPDATE)
  - DELETE /api/catalogos/{catalogo}/{item_id}        (DELETE)

Clasificación:
  1) Simples: (id, codigo, descripcion)
     - estado_oferta  -> proparcon.cat_estado_oferta_alquiler
     - estado_contrato-> proparcon.cat_estado_contrato
     - rol            -> proparcon.cat_rol
     - tipo_avaliador -> proparcon.cat_tipo_avaliador
     - tipo_contrato  -> proparcon.cat_tipo_contrato
     - tipo_derecho_propiedad -> proparcon.cat_tipo_derecho_propiedad
     - tipo_ingreso   -> proparcon.cat_tipo_ingreso
     - tipo_inmueble  -> proparcon.cat_tipo_inmueble
     - tipo_via       -> proparcon.cat_tipo_via

  2) Especiales:
     - pais: (id, iso2, nombre)
     - tipo_estancia: (id, codigo, descripcion, alquilable, es_raiz)

  3) Jerárquicos:
     - provincia: (id, pais_id, nombre)
       - LIST requiere ?pais_id=...
       - GET BY ID no requiere query

Compatibilidad de payload:
  - Front antiguo usa "nombre" en vez de "descripcion": se acepta y se mapea.
  - PATCH es parcial: NO obliga a mandar codigo/descripcion completos.

====================================================================
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from sqlalchemy.sql import text

from app.api.deps import get_db

router = APIRouter()


# --------------------------------------------------------------------
# SECCIÓN 1: Configuración centralizada de catálogos
# --------------------------------------------------------------------
class _CatCfg(BaseModel):
    kind: str                 # "simple" | "pais" | "tipo_estancia" | "provincia"
    table: str                # nombre completo tabla (schema.tabla)
    select_cols: Tuple[str, ...]  # columnas a devolver (en SELECT)
    insert_cols: Tuple[str, ...]  # columnas permitidas en INSERT
    update_cols: Tuple[str, ...]  # columnas permitidas en UPDATE


CATALOGOS: Dict[str, _CatCfg] = {
    # ---------------------------
    # Simples: (id, codigo, descripcion)
    # ---------------------------
    "estado_oferta": _CatCfg(
        kind="simple",
        table="proparcon.cat_estado_oferta_alquiler",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "estado_contrato": _CatCfg(
        kind="simple",
        table="proparcon.cat_estado_contrato",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_inmueble": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_inmueble",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_via": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_via",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "rol": _CatCfg(
        kind="simple",
        table="proparcon.cat_rol",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_avaliador": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_avaliador",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_contrato": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_contrato",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_derecho_propiedad": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_derecho_propiedad",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),
    "tipo_ingreso": _CatCfg(
        kind="simple",
        table="proparcon.cat_tipo_ingreso",
        select_cols=("id", "codigo", "descripcion"),
        insert_cols=("codigo", "descripcion"),
        update_cols=("codigo", "descripcion"),
    ),

    # ---------------------------
    # Especiales
    # ---------------------------
    "pais": _CatCfg(
        kind="pais",
        table="proparcon.cat_pais",
        select_cols=("id", "iso2", "nombre"),
        insert_cols=("iso2", "nombre"),
        update_cols=("iso2", "nombre"),
    ),
    "tipo_estancia": _CatCfg(
        kind="tipo_estancia",
        table="proparcon.cat_tipo_estancia",
        select_cols=("id", "codigo", "descripcion", "alquilable", "es_raiz"),
        insert_cols=("codigo", "descripcion", "alquilable", "es_raiz"),
        update_cols=("codigo", "descripcion", "alquilable", "es_raiz"),
    ),

    # ---------------------------
    # Jerárquicos
    # ---------------------------
    "provincia": _CatCfg(
        kind="provincia",
        table="proparcon.cat_provincia",
        select_cols=("id", "pais_id", "nombre"),
        insert_cols=("pais_id", "nombre"),
        update_cols=("pais_id", "nombre"),
    ),
}


def _get_cfg(catalogo: str) -> _CatCfg:
    cfg = CATALOGOS.get(catalogo)
    if not cfg:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Catálogo no soportado: {catalogo}",
        )
    return cfg


# --------------------------------------------------------------------
# SECCIÓN 2: Modelos de entrada (POST/PATCH)
#   Nota clave: PATCH ES PARCIAL -> campos opcionales
# --------------------------------------------------------------------
class CatalogoCreate(BaseModel):
    # Para simples / tipo_estancia
    codigo: Optional[str] = Field(default=None, max_length=40)
    descripcion: Optional[str] = None

    # alias compat (front)
    nombre: Optional[str] = None

    # pais
    iso2: Optional[str] = Field(default=None, min_length=2, max_length=2)

    # pais / provincia
    pais_id: Optional[int] = None

    # pais / provincia / pais
    # (para pais el campo correcto es "nombre"; para provincia el campo correcto es "nombre")
    # lo aceptamos en ambos.
    # NOTA: para simples "nombre" se mapea a "descripcion".
    # para pais/provincia "nombre" es real.
    # (ya existe arriba como alias compat, aquí se reutiliza)

    # tipo_estancia
    alquilable: Optional[bool] = None
    es_raiz: Optional[bool] = None


class CatalogoPatch(BaseModel):
    # PATCH: todo opcional, y solo actualiza lo que venga informado
    codigo: Optional[str] = Field(default=None, max_length=40)
    descripcion: Optional[str] = None
    nombre: Optional[str] = None

    iso2: Optional[str] = Field(default=None, min_length=2, max_length=2)
    pais_id: Optional[int] = None
    alquilable: Optional[bool] = None
    es_raiz: Optional[bool] = None


# --------------------------------------------------------------------
# SECCIÓN 3: Helpers SQL / payload
# --------------------------------------------------------------------
def _validate_id(item_id: str) -> int:
    # compat: tests antiguos mandaban "null"
    if item_id == "null" or not item_id.isdigit():
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="ID inválido",
        )
    return int(item_id)


def _payload_to_db_fields(cfg: _CatCfg, payload: Dict[str, Any], is_patch: bool) -> Dict[str, Any]:
    """
    Convierte payload de API a columnas reales según tipo de catálogo.
    - Simples: acepta {descripcion} o {nombre} (nombre -> descripcion).
    - Pais: usa (iso2, nombre). Si llega descripcion/nombre, prioriza nombre.
    - Provincia: usa (pais_id, nombre). Si llega descripcion, la ignora.
    - Tipo_estancia: (codigo, descripcion, alquilable, es_raiz); también acepta nombre->descripcion.
    """
    data: Dict[str, Any] = dict(payload)

    # Normalización "nombre" -> "descripcion" para simples / tipo_estancia
    if cfg.kind in ("simple", "tipo_estancia"):
        if data.get("descripcion") is None and data.get("nombre") is not None:
            data["descripcion"] = data.get("nombre")

    # Pais: si llega "descripcion" o "nombre", lo tratamos como "nombre"
    if cfg.kind == "pais":
        if data.get("nombre") is None and data.get("descripcion") is not None:
            data["nombre"] = data.get("descripcion")

    # Provincia: el campo humano es "nombre". Si llega "descripcion", lo ignoramos.
    if cfg.kind == "provincia":
        # nada especial; si llega nombre ok
        pass

    # Limpiamos claves no relacionadas, y dejamos solo columnas permitidas
    allowed = cfg.update_cols if is_patch else cfg.insert_cols
    out = {}
    for k in allowed:
        if k in data and data[k] is not None:
            out[k] = data[k]

    return out


def _row_to_api(cfg: _CatCfg, row: Dict[str, Any]) -> Dict[str, Any]:
    """
    Ajusta la respuesta a formato consistente para web/tests.
    - Simples: añade "nombre" como alias de "descripcion".
    - Pais: expone codigo=iso2 y descripcion=nombre para UI genérica.
    - Provincia: expone descripcion=nombre y codigo=null (para UI genérica).
    """
    if cfg.kind == "simple":
        return {
            "id": row["id"],
            "codigo": row.get("codigo"),
            "descripcion": row.get("descripcion"),
            "nombre": row.get("descripcion"),
        }

    if cfg.kind == "pais":
        return {
            "id": row["id"],
            "iso2": row.get("iso2"),
            "nombre": row.get("nombre"),
            "codigo": row.get("iso2"),
            "descripcion": row.get("nombre"),
        }

    if cfg.kind == "tipo_estancia":
        return {
            "id": row["id"],
            "codigo": row.get("codigo"),
            "descripcion": row.get("descripcion"),
            "nombre": row.get("descripcion"),
            "alquilable": row.get("alquilable"),
            "es_raiz": row.get("es_raiz"),
        }

    if cfg.kind == "provincia":
        return {
            "id": row["id"],
            "pais_id": row.get("pais_id"),
            "nombre": row.get("nombre"),
            "descripcion": row.get("nombre"),
            "codigo": None,
        }

    return dict(row)


def _select_one_by_id(cfg: _CatCfg, db: Session, item_id: int) -> Optional[Dict[str, Any]]:
    cols = ", ".join(cfg.select_cols)
    sql = text(f"SELECT {cols} FROM {cfg.table} WHERE id = :id")
    row = db.execute(sql, {"id": item_id}).mappings().first()
    return dict(row) if row else None


# --------------------------------------------------------------------
# SECCIÓN 4: Endpoints
# --------------------------------------------------------------------
@router.get("/{catalogo}")
def listar_catalogo(
    catalogo: str,
    db: Session = Depends(get_db),
    pais_id: Optional[int] = Query(default=None, description="Obligatorio para provincia"),
) -> List[Dict[str, Any]]:
    cfg = _get_cfg(catalogo)
    cols = ", ".join(cfg.select_cols)

    if cfg.kind == "provincia":
        if pais_id is None:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Para 'provincia' es obligatorio el parámetro query ?pais_id=...",
            )
        sql = text(f"SELECT {cols} FROM {cfg.table} WHERE pais_id = :pais_id ORDER BY nombre")
        rows = db.execute(sql, {"pais_id": pais_id}).mappings().all()
        return [_row_to_api(cfg, dict(r)) for r in rows]

    # orden humano razonable
    order_col = "descripcion" if "descripcion" in cfg.select_cols else ("nombre" if "nombre" in cfg.select_cols else "id")
    sql = text(f"SELECT {cols} FROM {cfg.table} ORDER BY {order_col}")
    rows = db.execute(sql).mappings().all()
    return [_row_to_api(cfg, dict(r)) for r in rows]


@router.get("/{catalogo}/{item_id}")
def obtener_catalogo_por_id(
    catalogo: str,
    item_id: str,
    db: Session = Depends(get_db),
) -> Dict[str, Any]:
    cfg = _get_cfg(catalogo)
    _id = _validate_id(item_id)

    row = _select_one_by_id(cfg, db, _id)
    if not row:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No encontrado")

    return _row_to_api(cfg, row)


@router.post("/{catalogo}", status_code=status.HTTP_201_CREATED)
def crear_item_catalogo(
    catalogo: str,
    payload: CatalogoCreate,
    db: Session = Depends(get_db),
) -> Dict[str, Any]:
    cfg = _get_cfg(catalogo)

    raw = payload.model_dump(exclude_unset=True)
    data = _payload_to_db_fields(cfg, raw, is_patch=False)

    # Validación de obligatorios por catálogo (según insert_cols)
    missing = [c for c in cfg.insert_cols if c not in data]
    if missing:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"Faltan campos obligatorios: {missing}",
        )

    cols = ", ".join(data.keys())
    vals = ", ".join([f":{k}" for k in data.keys()])

    try:
        sql = text(f"INSERT INTO {cfg.table} ({cols}) VALUES ({vals}) RETURNING id")
        new_id = db.execute(sql, data).scalar()
        db.commit()

        row = _select_one_by_id(cfg, db, int(new_id))
        return _row_to_api(cfg, row) if row else {"id": int(new_id)}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.patch("/{catalogo}/{item_id}")
def actualizar_item_catalogo(
    catalogo: str,
    item_id: str,
    payload: CatalogoPatch,
    db: Session = Depends(get_db),
) -> Dict[str, Any]:
    cfg = _get_cfg(catalogo)
    _id = _validate_id(item_id)

    raw = payload.model_dump(exclude_unset=True)
    data = _payload_to_db_fields(cfg, raw, is_patch=True)

    # PATCH parcial: si no llega nada actualizable -> 200 "sin cambios"
    if not data:
        return {"message": "Sin cambios"}

    set_clause = ", ".join([f"{k} = :{k}" for k in data.keys()])
    params = {**data, "id": _id}

    try:
        sql = text(f"UPDATE {cfg.table} SET {set_clause} WHERE id = :id")
        res = db.execute(sql, params)
        db.commit()

        if res.rowcount == 0:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No encontrado")

        row = _select_one_by_id(cfg, db, _id)
        return _row_to_api(cfg, row) if row else {"message": "Item actualizado"}
    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{catalogo}/{item_id}")
def borrar_item_catalogo(
    catalogo: str,
    item_id: str,
    db: Session = Depends(get_db),
) -> Dict[str, Any]:
    cfg = _get_cfg(catalogo)
    _id = _validate_id(item_id)

    try:
        sql = text(f"DELETE FROM {cfg.table} WHERE id = :id")
        res = db.execute(sql, {"id": _id})
        db.commit()

        if res.rowcount == 0:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No encontrado")

        return {"message": "Item eliminado"}
    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


--- ARCHIVO: app\api\catalogos.py ---
"""
===============================================================================
ARCHIVO: app/api/catalogos.py
PROYECTO: PROPARCON API
===============================================================================

OBJETIVO
- CRUD genérico para catálogos (simples / especiales / jerárquicos) alineado con
  la colección Postman y el DDL real en PostgreSQL (esquema: proparcon).

PROBLEMAS QUE SOLUCIONA (según tus logs y tests)
- PATCH devolvía 400 en varios catálogos porque el payload de Postman usa
  {"descripcion": "..."} y el backend no lo aceptaba -> update_data vacío.
- /api/catalogos/rol daba 404 porque no estaba mapeado.
- Se mantiene el endpoint GET By ID para evitar 405.

DECISIONES DE DISEÑO
- Un único router con rutas:
    GET    /{catalogo}
    GET    /{catalogo}/{item_id}
    POST   /{catalogo}
    PATCH  /{catalogo}/{item_id}
    DELETE /{catalogo}/{item_id}

- Validación por tipo de catálogo:
  - "simples": codigo + descripcion
  - "pais": iso2 + nombre
  - "provincia": pais_id + nombre (y listado filtrable por pais_id)
  - "tipo_estancia": codigo + descripcion + alquilable + es_raiz

- Seguridad:
  - Requiere JWT con Depends(get_current_user).
  - NO usa RoleChecker para no depender de rutas/imports inestables.

NOTA
- Este archivo asume que existe app.api.deps con get_db y get_current_user.
===============================================================================
"""

from __future__ import annotations

from typing import Any, Dict, Optional, List, Tuple

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from sqlalchemy.sql import text

from app.api.deps import get_db, get_current_user

# -----------------------------------------------------------------------------
# SECCIÓN 1: Router + Seguridad (JWT obligatorio)
# -----------------------------------------------------------------------------

router = APIRouter(
    dependencies=[Depends(get_current_user)],
)

SCHEMA = "proparcon"

# -----------------------------------------------------------------------------
# SECCIÓN 2: Modelos Pydantic (entrada flexible para no romper Postman/UI)
# -----------------------------------------------------------------------------

class CatalogoCreate(BaseModel):
    """
    Payload de creación. Se valida por catálogo.
    Se permiten campos extra según el tipo de catálogo.
    """
    codigo: Optional[str] = None
    descripcion: Optional[str] = None

    # especiales
    iso2: Optional[str] = None
    nombre: Optional[str] = None

    # jerárquicos
    pais_id: Optional[int] = None

    # especiales tipo_estancia
    alquilable: Optional[bool] = None
    es_raiz: Optional[bool] = None


class CatalogoUpdate(BaseModel):
    """
    Payload de actualización parcial.
    IMPORTANTE: Postman usa "descripcion" (y no "nombre") en varios catálogos.
    Por eso debe existir aquí, siempre.
    """
    codigo: Optional[str] = None
    descripcion: Optional[str] = None

    iso2: Optional[str] = None
    nombre: Optional[str] = None

    pais_id: Optional[int] = None

    alquilable: Optional[bool] = None
    es_raiz: Optional[bool] = None


# -----------------------------------------------------------------------------
# SECCIÓN 3: Mapeo catálogo -> tabla y columnas válidas
# -----------------------------------------------------------------------------

# Catálogos "simples": (tabla, columnas)
#   id + codigo + descripcion
SIMPLE_CATALOGS: Dict[str, Tuple[str, List[str]]] = {
    # los 4 iniciales
    "estado_oferta": ("cat_estado_oferta_alquiler", ["codigo", "descripcion"]),
    "estado_contrato": ("cat_estado_contrato", ["codigo", "descripcion"]),
    "tipo_inmueble": ("cat_tipo_inmueble", ["codigo", "descripcion"]),
    "tipo_via": ("cat_tipo_via", ["codigo", "descripcion"]),

    # el que te faltaba (404)
    "rol": ("cat_rol", ["codigo", "descripcion"]),

    # resto DDL compartido
    "tipo_avaliador": ("cat_tipo_avaliador", ["codigo", "descripcion"]),
    "tipo_contrato": ("cat_tipo_contrato", ["codigo", "descripcion"]),
    "tipo_derecho_propiedad": ("cat_tipo_derecho_propiedad", ["codigo", "descripcion"]),
    "tipo_ingreso": ("cat_tipo_ingreso", ["codigo", "descripcion"]),
}

# Especial: país
PAIS_CATALOG = ("cat_pais", ["iso2", "nombre"])

# Jerárquico: provincia (siempre filtrable por país)
PROVINCIA_CATALOG = ("cat_provincia", ["pais_id", "nombre"])

# Especial: tipo_estancia (tiene flags)
TIPO_ESTANCIA_CATALOG = ("cat_tipo_estancia", ["codigo", "descripcion", "alquilable", "es_raiz"])


def _resolve_catalogo(catalogo: str) -> Tuple[str, List[str]]:
    """
    Devuelve (tabla, columnas_validas) según el nombre lógico del catálogo.
    """
    if catalogo in SIMPLE_CATALOGS:
        return SIMPLE_CATALOGS[catalogo]

    if catalogo == "pais":
        return PAIS_CATALOG

    if catalogo == "provincia":
        return PROVINCIA_CATALOG

    if catalogo == "tipo_estancia":
        return TIPO_ESTANCIA_CATALOG

    raise HTTPException(status_code=404, detail=f"Catálogo no soportado: {catalogo}")


def _table_fullname(table: str) -> str:
    return f"{SCHEMA}.{table}"


# -----------------------------------------------------------------------------
# SECCIÓN 4: Helpers SQL (select/insert/update/delete)
# -----------------------------------------------------------------------------

def _select_list_sql(table: str, where_clause: str = "", order_by: str = "id") -> str:
    wc = f" WHERE {where_clause}" if where_clause else ""
    return f"SELECT * FROM {_table_fullname(table)}{wc} ORDER BY {order_by} ASC"


def _select_by_id_sql(table: str) -> str:
    return f"SELECT * FROM {_table_fullname(table)} WHERE id = :id"


def _insert_sql(table: str, cols: List[str]) -> str:
    cols_sql = ", ".join(cols)
    vals_sql = ", ".join([f":{c}" for c in cols])
    return f"INSERT INTO {_table_fullname(table)} ({cols_sql}) VALUES ({vals_sql}) RETURNING id"


def _update_sql(table: str, cols: List[str]) -> str:
    set_sql = ", ".join([f"{c} = :{c}" for c in cols])
    return f"UPDATE {_table_fullname(table)} SET {set_sql} WHERE id = :id RETURNING id"


def _delete_sql(table: str) -> str:
    return f"DELETE FROM {_table_fullname(table)} WHERE id = :id"


def _filter_payload(payload: Dict[str, Any], allowed_cols: List[str]) -> Dict[str, Any]:
    """
    Filtra el payload para que solo incluya columnas permitidas para ese catálogo.
    """
    return {k: v for k, v in payload.items() if k in allowed_cols and v is not None}


def _require_fields(payload: Dict[str, Any], required: List[str]) -> None:
    missing = [f for f in required if payload.get(f) is None]
    if missing:
        raise HTTPException(
            status_code=422,
            detail=f"Faltan campos requeridos: {missing}",
        )


# -----------------------------------------------------------------------------
# SECCIÓN 5: Endpoints CRUD
# -----------------------------------------------------------------------------

@router.get("/{catalogo}", response_model=List[dict])
def listar_catalogo(
    catalogo: str,
    db: Session = Depends(get_db),
    pais_id: Optional[int] = Query(default=None, description="Filtro obligatorio en UI para provincia"),
) -> List[dict]:
    """
    Lista items de un catálogo.
    - provincia: puede filtrarse por pais_id (en UI debe usarse siempre).
    """
    table, cols = _resolve_catalogo(catalogo)

    where_clause = ""
    params: Dict[str, Any] = {}

    if catalogo == "provincia":
        # En UI debe venir siempre; en API lo permitimos opcional para no romper scripts,
        # pero si quieres forzarlo 100% lo convertimos en obligatorio.
        if pais_id is not None:
            where_clause = "pais_id = :pais_id"
            params["pais_id"] = pais_id

    sql = text(_select_list_sql(table, where_clause=where_clause, order_by="id"))
    rows = db.execute(sql, params).mappings().all()
    return [dict(r) for r in rows]


@router.get("/{catalogo}/{item_id}", response_model=dict)
def obtener_catalogo_por_id(
    catalogo: str,
    item_id: int,
    db: Session = Depends(get_db),
) -> dict:
    """
    Obtiene un registro por id.
    (Esto evita el 405 que veías cuando no existía este endpoint.)
    """
    table, _ = _resolve_catalogo(catalogo)

    sql = text(_select_by_id_sql(table))
    row = db.execute(sql, {"id": item_id}).mappings().first()
    if not row:
        raise HTTPException(status_code=404, detail="No encontrado")
    return dict(row)


@router.post("/{catalogo}", status_code=status.HTTP_201_CREATED)
def crear_item_catalogo(
    catalogo: str,
    datos: CatalogoCreate,
    db: Session = Depends(get_db),
) -> dict:
    """
    Crea un item en el catálogo.
    """
    table, allowed_cols = _resolve_catalogo(catalogo)
    payload = datos.model_dump(exclude_unset=True)

    # Normalización mínima (evita strings vacíos)
    for k, v in list(payload.items()):
        if isinstance(v, str) and not v.strip():
            payload.pop(k, None)

    filtered = _filter_payload(payload, allowed_cols)

    # Reglas por catálogo
    if catalogo in SIMPLE_CATALOGS:
        _require_fields(filtered, ["codigo", "descripcion"])
    elif catalogo == "pais":
        _require_fields(filtered, ["iso2", "nombre"])
    elif catalogo == "provincia":
        _require_fields(filtered, ["pais_id", "nombre"])
    elif catalogo == "tipo_estancia":
        _require_fields(filtered, ["codigo", "descripcion"])
        # flags opcionales: si no vienen, se respetan defaults de BD

    if not filtered:
        raise HTTPException(status_code=422, detail="Payload vacío o inválido")

    try:
        sql = text(_insert_sql(table, list(filtered.keys())))
        new_id = db.execute(sql, filtered).scalar()
        db.commit()
        return {"id": int(new_id), "status": "created"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))


@router.patch("/{catalogo}/{item_id}")
def actualizar_item_catalogo(
    catalogo: str,
    item_id: int,
    datos: CatalogoUpdate,
    db: Session = Depends(get_db),
) -> dict:
    """
    Actualiza parcialmente un item.
    CLAVE: soporta PATCH con {"descripcion": "..."} (tal como Postman).
    """
    table, allowed_cols = _resolve_catalogo(catalogo)
    payload = datos.model_dump(exclude_unset=True)

    # Normalización mínima
    for k, v in list(payload.items()):
        if isinstance(v, str) and not v.strip():
            payload.pop(k, None)

    filtered = _filter_payload(payload, allowed_cols)
    if not filtered:
        # Esto es exactamente lo que te estaba provocando 400:
        # Postman manda descripcion, pero si el modelo no la aceptaba, quedaba vacío.
        raise HTTPException(status_code=400, detail="Sin cambios (payload vacío o campos no permitidos)")

    try:
        sql = text(_update_sql(table, list(filtered.keys())))
        res = db.execute(sql, {**filtered, "id": item_id}).first()
        if not res:
            db.rollback()
            raise HTTPException(status_code=404, detail="No encontrado")
        db.commit()
        return {"id": item_id, "status": "updated"}
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))


@router.delete("/{catalogo}/{item_id}")
def borrar_item_catalogo(
    catalogo: str,
    item_id: int,
    db: Session = Depends(get_db),
) -> dict:
    """
    Borra un item.
    """
    table, _ = _resolve_catalogo(catalogo)

    try:
        sql = text(_delete_sql(table))
        db.execute(sql, {"id": item_id})
        db.commit()
        return {"id": item_id, "status": "deleted"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))


--- ARCHIVO: app\api\contrato.py ---
"""
====================================================================
ARCHIVO: app/api/contrato.py
PROYECTO: PROPARCON API
DESCRIPCIÓN: Gestión Transaccional de Alquileres (Fiel a versión estable).
====================================================================
ACTUALIZACIÓN REALIZADA:
    ✅ RESTAURACIÓN TEST 11 y 12: Se separa estrictamente el borrado 
       del contrato del borrado de inquilinos para que Postman pueda 
       validar cada paso de forma independiente como hacía antes.
    ✅ ELIMINACIÓN DE DOBLE LIMPIEZA: Se elimina la limpieza preventiva 
       dentro del DELETE de contrato que causaba el 404 en el Test 12.
    ✅ FULL COMPATIBILITY: Mantiene la estructura de 'payload' e 
       'inquilinos' exacta de tus pruebas exitosas.
====================================================================
"""

from typing import List, Optional
from datetime import date
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from app.api.deps import get_db

router = APIRouter()

# --------------------------------------------------------------------
# SECCIÓN 1: MODELOS PYDANTIC
# --------------------------------------------------------------------
class ContratoPayload(BaseModel):
    estancia_id: int
    oferta_id: int
    fecha_inicio: date
    monto_renta: float

class InquilinoRef(BaseModel):
    id: int

class ContratoRequest(BaseModel):
    payload: ContratoPayload
    inquilinos: List[InquilinoRef]

# --------------------------------------------------------------------
# SECCIÓN 2: CONSULTAS (GET)
# --------------------------------------------------------------------

@router.get("", response_model=List[dict])
def listar_contratos(db: Session = Depends(get_db)):
    sql = text("SELECT * FROM proparcon.alquiler_contrato ORDER BY id DESC")
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

@router.get("/{contrato_id}")
def leer_contrato(contrato_id: int, db: Session = Depends(get_db)):
    sql = text("SELECT * FROM proparcon.alquiler_contrato WHERE id = :id")
    res = db.execute(sql, {"id": contrato_id}).mappings().first()
    if not res:
        raise HTTPException(404, "Contrato no encontrado")
    return dict(res)

# --------------------------------------------------------------------
# SECCIÓN 3: REGISTRO (POST) - Test 06
# --------------------------------------------------------------------

@router.post("", status_code=status.HTTP_201_CREATED)
def formalizar_contrato(datos: ContratoRequest, db: Session = Depends(get_db)):
    try:
        sql_c = text("""
            INSERT INTO proparcon.alquiler_contrato (estancia_id, oferta_id, fecha_inicio, renta_mensual) 
            VALUES (:e, :o, :f, :r) RETURNING id
        """)
        res_c = db.execute(sql_c, {
            "e": datos.payload.estancia_id, "o": datos.payload.oferta_id,
            "f": datos.payload.fecha_inicio, "r": datos.payload.monto_renta
        }).first()
        c_id = res_c[0]

        for i, inq in enumerate(datos.inquilinos):
            db.execute(text("""
                INSERT INTO proparcon.alquiler_contrato_inquilino (contrato_id, persona_id, es_titular) 
                VALUES (:c, :p, :t)
            """), {"c": c_id, "p": inq.id, "t": (i == 0)})
        
        db.commit()
        return {"id": c_id, "message": "Contrato formalizado"}
    except Exception as e:
        db.rollback()
        raise HTTPException(400, detail=str(e))

# --------------------------------------------------------------------
# SECCIÓN 5: ELIMINACIÓN FÍSICA SEPARADA (Tests 11 y 12)
# --------------------------------------------------------------------

@router.delete("/{contrato_id}")
def eliminar_contrato_principal(contrato_id: int, db: Session = Depends(get_db)):
    """
    TEST 11: Borra solo el contrato.
    Se ha eliminado la limpieza de inquilinos de aquí para evitar que 
    el Test 12 falle por encontrar el recurso ya vacío.
    """
    sql = text("DELETE FROM proparcon.alquiler_contrato WHERE id = :id RETURNING id")
    res = db.execute(sql, {"id": contrato_id}).first()
    db.commit()
    
    if not res:
        raise HTTPException(404, "Contrato no encontrado")
    return {"id": res[0], "message": "Contrato eliminado físicamente"}

@router.delete("/{contrato_id}/inquilinos")
def eliminar_inquilinos_de_contrato(contrato_id: int, db: Session = Depends(get_db)):
    """
    TEST 12: Verifica la limpieza de la tabla intermedia.
    Este endpoint es independiente y debe ejecutarse según la lógica 
    de tu colección de Postman.
    """
    sql = text("DELETE FROM proparcon.alquiler_contrato_inquilino WHERE contrato_id = :id RETURNING id")
    res = db.execute(sql, {"id": contrato_id}).all()
    db.commit()
    
    # IMPORTANTE: No validamos existencia del contrato padre aquí para 
    # permitir la limpieza de huérfanos si la prueba lo requiere.
    return {
        "contrato_id": contrato_id, 
        "vinculos_eliminados": len(res)
    }

--- ARCHIVO: app\api\deps.py ---
"""
====================================================================
DEPS.PY: Dependencias Globales e Inyección de Seguridad
====================================================================
Descripción:
  - Inyección de sesión DB
  - Extracción/validación de JWT
  - RBAC (RoleChecker) para proteger routers

Notas:
  - Se importa UserRole para soportar dependencias del agregador de routers
    y/o anotaciones de tipo sin NameError.
  - Se usa 'from __future__ import annotations' para evitar evaluación
    temprana de type hints.
====================================================================
"""

from __future__ import annotations

from typing import Generator, List, Sequence, Union

from fastapi import Depends, HTTPException, status
from jose import JWTError, jwt
from sqlalchemy.orm import Session

from app.core.db import SessionLocal
from app.core.security import ALGORITHM, SECRET_KEY, oauth2_scheme
from app.models.users import User, UserRole

# --------------------------------------------------------------------
# SECCIÓN 1: BASE DE DATOS
# --------------------------------------------------------------------
def get_db() -> Generator:
    """Inyección de sesión de SQLAlchemy para los endpoints."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# --------------------------------------------------------------------
# SECCIÓN 2: VALIDACIÓN DE IDENTIDAD
# --------------------------------------------------------------------
def get_current_user(
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme),
) -> User:
    """Extrae el email (sub) del JWT y busca al usuario en BD."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar el token de acceso",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str | None = payload.get("sub")
        if not email:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception

    return user


# --------------------------------------------------------------------
# SECCIÓN 3: CONTROL DE ROLES (RBAC)
# --------------------------------------------------------------------
class RoleChecker:
    """
    Verifica que el usuario autenticado tenga uno de los roles requeridos.

    Uso típico:
      - dependencies=[Depends(RoleChecker([UserRole.ADMIN, UserRole.GESTOR]))]
      - dependencies=[Depends(RoleChecker([UserRole.ADMIN]))]
    """

    def __init__(self, allowed_roles: Sequence[Union[UserRole, str]]):
        self.allowed_roles = allowed_roles

    def __call__(self, current_user: User = Depends(get_current_user)) -> User:
        # current_user.role en tu modelo es String(20), pero también soportamos Enum por si evoluciona.
        user_role = (
            current_user.role.value
            if hasattr(current_user.role, "value")
            else str(current_user.role)
        )

        # Convertimos roles permitidos a string para comparación homogénea
        allowed = [
            r.value if hasattr(r, "value") else str(r)
            for r in self.allowed_roles
        ]

        if user_role not in allowed:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=(
                    f"Permiso denegado. Se requiere uno de estos roles: {allowed}. "
                    f"Tu rol es: {user_role}"
                ),
            )

        return current_user


--- ARCHIVO: app\api\estancia.py ---
"""
====================================================================
ARCHIVO: app/api/estancia.py
PROYECTO: PROPARCON API
DESCRIPCIÓN: Gestión de estancias (Inmueble -> Estancia).
====================================================================
ACTUALIZACIÓN REALIZADA:
    ✅ VISTA JERÁRQUICA: Consulta SQL optimizada para agrupar por 
       Inmueble, incluyendo la descripción del catálogo de tipos.
    ✅ ESTABILIDAD: Se mantienen los endpoints de CRUD necesarios
       para la integración con el Frontend.
====================================================================
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from app.api.deps import get_db

router = APIRouter()

# --------------------------------------------------------------------
# SECCIÓN 1: MODELOS PYDANTIC
# --------------------------------------------------------------------

class EstanciaCreate(BaseModel):
    inmueble_id: int
    tipo_estancia_id: int
    nombre: str

class EstanciaUpdate(BaseModel):
    tipo_estancia_id: Optional[int] = None
    nombre: Optional[str] = None

# --------------------------------------------------------------------
# SECCIÓN 2: CONSULTAS (GET)
# --------------------------------------------------------------------

@router.get("", response_model=List[dict])
def listar_estancias_agrupadas(db: Session = Depends(get_db)):
    """Obtiene estancias ordenadas por inmueble para la jerarquía web."""
    sql = text("""
        SELECT 
            e.id, e.inmueble_id, e.tipo_estancia_id, e.nombre,
            i.nombre_publico as inmueble_nombre,
            te.descripcion as tipo_estancia_desc
        FROM proparcon.estancia e
        JOIN proparcon.inmueble i ON e.inmueble_id = i.id
        LEFT JOIN proparcon.cat_tipo_estancia te ON e.tipo_estancia_id = te.id
        ORDER BY i.nombre_publico ASC, e.nombre ASC
    """)
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

@router.get("/tipos", response_model=List[dict])
def listar_tipos_estancia(db: Session = Depends(get_db)):
    sql = text("SELECT id, descripcion FROM proparcon.cat_tipo_estancia ORDER BY id")
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

# --------------------------------------------------------------------
# SECCIÓN 3: ESCRITURA (POST / PATCH / DELETE)
# --------------------------------------------------------------------

@router.post("", status_code=status.HTTP_201_CREATED)
def crear_estancia(datos: EstanciaCreate, db: Session = Depends(get_db)):
    sql = text("""
        INSERT INTO proparcon.estancia (inmueble_id, tipo_estancia_id, nombre) 
        VALUES (:i, :t, :n) RETURNING id
    """)
    res = db.execute(sql, {"i": datos.inmueble_id, "t": datos.tipo_estancia_id, "n": datos.nombre}).first()
    db.commit()
    return {"id": res[0], "message": "Estancia creada"}

@router.patch("/{estancia_id}")
def actualizar_estancia(estancia_id: int, datos: EstanciaUpdate, db: Session = Depends(get_db)):
    update_data = datos.model_dump(exclude_unset=True)
    if not update_data: raise HTTPException(400, "Sin cambios")
    set_clause = ", ".join([f"{k} = :{k}" for k in update_data.keys()])
    sql = text(f"UPDATE proparcon.estancia SET {set_clause} WHERE id = :id RETURNING id")
    db.execute(sql, {**update_data, "id": estancia_id})
    db.commit()
    return {"id": estancia_id, "status": "updated"}

@router.delete("/{estancia_id}")
def eliminar_estancia(estancia_id: int, db: Session = Depends(get_db)):
    db.execute(text("DELETE FROM proparcon.estancia WHERE id = :id"), {"id": estancia_id})
    db.commit()
    return {"message": "Borrado"}

--- ARCHIVO: app\api\infra.py ---
"""
====================================================================
INFRA.PY: Guardián de Salud del Sistema (Health Check)
====================================================================
Estado: ✅ Revisado
Sección: Mantenimiento e Infraestructura
"""

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from sqlalchemy.sql import text

# 📌 IMPORTACIONES DE SEGURIDAD
from app.api.deps import get_db, RoleChecker
from app.models.users import UserRole

router = APIRouter(prefix="/api/infra", tags=["Infraestructura"])

@router.get("/health")
def health_status(
    db: Session = Depends(get_db),
    _ = Depends(RoleChecker([UserRole.ADMIN]))
):
    """Endpoint crítico para verificar la conexión real con PostgreSQL."""
    try:
        # Prueba de fuego: consulta al esquema proparcon
        db.execute(text("SELECT 1 FROM proparcon.users LIMIT 1"))
        return {
            "status": "online",
            "db_connection": "established",
            "schema": "proparcon",
            "rbac": "active"
        }
    except Exception as e:
        return {
            "status": "error",
            "message": f"Fallo en infraestructura: {str(e)}"
        }

--- ARCHIVO: app\api\inmueble.py ---
"""
====================================================================
ARCHIVO: app/api/inmueble.py
PROYECTO: PROPARCON API
DESCRIPCIÓN: Gestión Integral de Activos Inmobiliarios y Catastro.
====================================================================
ACTUALIZACIÓN REALIZADA:
    ✅ ADICIÓN DE LISTADO GLOBAL: Se ha implementado el método GET raíz 
       (@router.get("")) para permitir que el Frontend cargue la tabla 
       y los selectores de inmuebles (Solución definitiva al Error 405).
    ✅ INTEGRACIÓN CATASTRAL: El listado y la consulta por ID incluyen 
       ahora un LEFT JOIN con la tabla 'catastro' para devolver la 
       referencia catastral vinculada.
    ✅ COMPATIBILIDAD POSTMAN: Se mantienen los endpoints existentes 
       para asegurar que tus pruebas actuales sigan siendo válidas.
====================================================================
"""

from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from app.api.deps import get_db

router = APIRouter()

# --------------------------------------------------------------------
# SECCIÓN 1: MODELOS PYDANTIC (Validación de Esquemas)
# --------------------------------------------------------------------

class InmuebleCreate(BaseModel):
    """Esquema para la creación de un nuevo inmueble."""
    tipo_inmueble_id: int
    nombre_publico: str = Field(..., min_length=3)
    direccion_id: int
    referencia_catastral: Optional[str] = None

class InmuebleUpdate(BaseModel):
    """Esquema para la actualización parcial (PATCH) de un inmueble."""
    nombre_publico: Optional[str] = None
    tipo_inmueble_id: Optional[int] = None
    direccion_id: Optional[int] = None

# --------------------------------------------------------------------
# SECCIÓN 2: CONSULTAS (GET) - Lectura de Activos
# --------------------------------------------------------------------

@router.get("", response_model=List[dict])
def listar_inmuebles(db: Session = Depends(get_db)):
    """
    Lista todos los inmuebles registrados.
    Realiza un LEFT JOIN con catastro para mostrar la referencia si existe.
    """
    sql = text("""
        SELECT i.*, c.ref_catastral 
        FROM proparcon.inmueble i 
        LEFT JOIN proparcon.catastro c ON i.id = c.inmueble_id 
        ORDER BY i.id DESC
    """)
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

@router.get("/{inmueble_id}")
def obtener_inmueble(inmueble_id: int, db: Session = Depends(get_db)):
    """
    Obtiene los detalles de un inmueble específico por ID.
    """
    sql = text("""
        SELECT i.*, c.ref_catastral 
        FROM proparcon.inmueble i 
        LEFT JOIN proparcon.catastro c ON i.id = c.inmueble_id 
        WHERE i.id = :id
    """)
    res = db.execute(sql, {"id": inmueble_id}).mappings().first()
    if not res:
        raise HTTPException(status_code=404, detail="Inmueble no encontrado")
    return dict(res)

# --------------------------------------------------------------------
# SECCIÓN 3: ESCRITURA (POST) - Registro Transaccional
# --------------------------------------------------------------------

@router.post("", status_code=status.HTTP_201_CREATED)
def crear_inmueble_completo(datos: InmuebleCreate, db: Session = Depends(get_db)):
    """
    Crea un inmueble y su registro catastral asociado en una sola operación.
    """
    try:
        # 1. Registro del Inmueble
        sql_i = text("""
            INSERT INTO proparcon.inmueble (nombre_publico, direccion_id, tipo_inmueble_id) 
            VALUES (:n, :d, :t) RETURNING id
        """)
        res_i = db.execute(sql_i, {
            "n": datos.nombre_publico, 
            "d": datos.direccion_id, 
            "t": datos.tipo_inmueble_id
        }).first()
        nuevo_id = res_i[0]

        # 2. Registro del Catastro (si aplica)
        if datos.referencia_catastral:
            sql_c = text("""
                INSERT INTO proparcon.catastro (inmueble_id, ref_catastral) 
                VALUES (:id, :ref)
            """)
            db.execute(sql_c, {"id": nuevo_id, "ref": datos.referencia_catastral})
        
        db.commit()
        return {"id": nuevo_id, "message": "Inmueble y catastro registrados"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

# --------------------------------------------------------------------
# SECCIÓN 4: ACTUALIZACIÓN (PATCH) - Modificación Parcial
# --------------------------------------------------------------------

@router.patch("/{inmueble_id}")
def actualizar_inmueble(inmueble_id: int, datos: InmuebleUpdate, db: Session = Depends(get_db)):
    """
    Actualiza campos específicos del inmueble sin afectar al resto.
    """
    update_data = datos.model_dump(exclude_unset=True)
    if not update_data:
        raise HTTPException(status_code=400, detail="Nada que actualizar")
    
    set_clause = ", ".join([f"{k} = :{k}" for k in update_data.keys()])
    sql = text(f"UPDATE proparcon.inmueble SET {set_clause} WHERE id = :id RETURNING id")
    
    try:
        res = db.execute(sql, {**update_data, "id": inmueble_id}).first()
        if not res:
            raise HTTPException(404, "Inmueble no encontrado")
        db.commit()
        return {"id": res[0], "message": "Actualizado correctamente"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

# --------------------------------------------------------------------
# SECCIÓN 5: ELIMINACIÓN (DELETE) - Limpieza de Activos
# --------------------------------------------------------------------

@router.delete("/{inmueble_id}")
def eliminar_inmueble_total(inmueble_id: int, db: Session = Depends(get_db)):
    """
    Borrado en cascada (manual) de catastro e inmueble.
    """
    try:
        db.execute(text("DELETE FROM proparcon.catastro WHERE inmueble_id = :id"), {"id": inmueble_id})
        db.execute(text("DELETE FROM proparcon.inmueble WHERE id = :id"), {"id": inmueble_id})
        db.commit()
        return {"message": "Inmueble eliminado con éxito"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Error al eliminar: {str(e)}")

--- ARCHIVO: app\api\oferta.py ---
"""
====================================================================
ARCHIVO: app/api/oferta.py
PROYECTO: PROPARCON API
DESCRIPCIÓN:
    Gestión Comercial (Inmueble -> Estancia -> Oferta).
====================================================================
ACTUALIZACIÓN:
    ✅ Añadido GET /{oferta_id} (necesario para CRUD completo y Postman)
    ✅ Mantiene compatibilidad total con endpoints existentes
====================================================================
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy.sql import text

from app.api.deps import get_db

router = APIRouter()

# -------------------------------------------------------------------
# SECCIÓN 1: MODELOS PYDANTIC
# -------------------------------------------------------------------
class OfertaCreate(BaseModel):
    estancia_id: int
    renta_mensual: float
    fecha_alta: str
    estado_id: int = 1


class OfertaUpdate(BaseModel):
    renta_mensual: Optional[float] = None
    estado_id: Optional[int] = None
    fecha_baja: Optional[str] = None


# -------------------------------------------------------------------
# SECCIÓN 2: CONSULTAS (GET)
# -------------------------------------------------------------------
@router.get("", response_model=List[dict])
def listar_ofertas(db: Session = Depends(get_db)):
    """Obtiene ofertas unidas con estancia e inmueble para jerarquía."""
    sql = text("""
        SELECT 
            o.*,
            e.nombre AS estancia_nombre,
            i.nombre_publico AS inmueble_nombre,
            i.id AS inmueble_id
        FROM proparcon.alquiler_oferta o
        JOIN proparcon.estancia e ON o.estancia_id = e.id
        JOIN proparcon.inmueble i ON e.inmueble_id = i.id
        ORDER BY i.nombre_publico ASC, e.nombre ASC
    """)
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]


@router.get("/{oferta_id}", response_model=dict)
def obtener_oferta(oferta_id: int, db: Session = Depends(get_db)):
    """Obtiene una oferta por ID (necesario para CRUD completo)."""
    sql = text("""
        SELECT 
            o.*,
            e.nombre AS estancia_nombre,
            i.nombre_publico AS inmueble_nombre,
            i.id AS inmueble_id
        FROM proparcon.alquiler_oferta o
        JOIN proparcon.estancia e ON o.estancia_id = e.id
        JOIN proparcon.inmueble i ON e.inmueble_id = i.id
        WHERE o.id = :id
    """)
    res = db.execute(sql, {"id": oferta_id}).mappings().first()

    if not res:
        raise HTTPException(status_code=404, detail="Oferta no encontrada")

    return dict(res)


# -------------------------------------------------------------------
# SECCIÓN 3: ESCRITURA (POST / PATCH / DELETE)
# -------------------------------------------------------------------
@router.post("", status_code=status.HTTP_201_CREATED)
def crear_oferta(datos: OfertaCreate, db: Session = Depends(get_db)):
    sql = text("""
        INSERT INTO proparcon.alquiler_oferta
            (estancia_id, renta_mensual, fecha_alta, estado_id)
        VALUES
            (:e, :r, :f, :s)
        RETURNING id
    """)
    res = db.execute(
        sql,
        {
            "e": datos.estancia_id,
            "r": datos.renta_mensual,
            "f": datos.fecha_alta,
            "s": datos.estado_id,
        },
    ).first()

    db.commit()
    return {"id": res[0], "message": "Oferta publicada"}


@router.patch("/{oferta_id}")
def actualizar_oferta(oferta_id: int, datos: OfertaUpdate, db: Session = Depends(get_db)):
    update_data = datos.model_dump(exclude_unset=True)
    if not update_data:
        raise HTTPException(status_code=400, detail="Sin cambios")

    set_clause = ", ".join([f"{k} = :{k}" for k in update_data.keys()])
    sql = text(f"""
        UPDATE proparcon.alquiler_oferta
        SET {set_clause}
        WHERE id = :id
        RETURNING id
    """)

    res = db.execute(sql, {**update_data, "id": oferta_id}).first()
    if not res:
        raise HTTPException(status_code=404, detail="Oferta no encontrada")

    db.commit()
    return {"id": oferta_id, "status": "updated"}


@router.delete("/{oferta_id}")
def eliminar_oferta(oferta_id: int, db: Session = Depends(get_db)):
    res = db.execute(
        text("DELETE FROM proparcon.alquiler_oferta WHERE id = :id RETURNING id"),
        {"id": oferta_id},
    ).first()

    if not res:
        raise HTTPException(status_code=404, detail="Oferta no encontrada")

    db.commit()
    return {"message": "Oferta eliminada"}


--- ARCHIVO: app\api\persona.py ---
"""
====================================================================
ARCHIVO: app/api/persona.py
PROYECTO: PROPARCON API
====================================================================
ESTADO: ✅ Revisado y Actualizado
CAMBIOS:
    - Añadido endpoint GET (lista completa) para evitar Error 405.
    - Sincronización de rutas sin slash final.
    - Tipado de respuesta corregido.
====================================================================
"""
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field, EmailStr
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from app.api.deps import get_db

router = APIRouter()

# --- 1. MODELOS DE VALIDACIÓN (PYDANTIC) ---
class PersonaCreate(BaseModel):
    tipo_doc: str = "DNI"
    doc_identidad: str = Field(..., min_length=3)
    nombre: str
    apellido1: str
    apellido2: Optional[str] = None
    email: Optional[EmailStr] = None

class PersonaUpdate(BaseModel):
    nombre: Optional[str] = None
    email_particular: Optional[EmailStr] = None
    telefono_movil: Optional[str] = None

# --- 2. ENDPOINTS DE CONSULTA (GET) ---

@router.get("", response_model=List[dict])
def obtener_personas(db: Session = Depends(get_db)):
    """
    Obtiene el listado completo de personas.
    Esencial para la vista de tabla en el frontend.
    """
    sql = text("SELECT * FROM proparcon.persona ORDER BY id DESC")
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

@router.get("/{persona_id}")
def obtener_persona(persona_id: int, db: Session = Depends(get_db)):
    """
    Obtiene los detalles de una persona específica.
    """
    sql = text("SELECT * FROM proparcon.persona WHERE id = :id")
    res = db.execute(sql, {"id": persona_id}).mappings().first()
    if not res:
        raise HTTPException(status_code=404, detail="Persona no encontrada")
    return dict(res)

# --- 3. ENDPOINTS DE CREACIÓN (POST) ---

@router.post("", status_code=status.HTTP_201_CREATED)
def crear_persona(datos: PersonaCreate, db: Session = Depends(get_db)):
    """
    Crea un nuevo registro de persona.
    """
    sql = text("""
        INSERT INTO proparcon.persona (nombre, apellido1, tipo_doc, doc_identidad, email_particular) 
        VALUES (:n, :a, :t, :d, :e) RETURNING id
    """)
    res = db.execute(sql, {
        "n": datos.nombre, 
        "a": datos.apellido1, 
        "t": datos.tipo_doc, 
        "d": datos.doc_identidad, 
        "e": datos.email
    }).first()
    db.commit()
    return {"id": res[0], "message": "Persona creada exitosamente"}

# --- 4. ENDPOINTS DE ACTUALIZACIÓN (PATCH) ---

@router.patch("/{persona_id}")
def actualizar_persona(persona_id: int, datos: PersonaUpdate, db: Session = Depends(get_db)):
    """
    Actualización parcial de datos de una persona.
    """
    update_data = datos.model_dump(exclude_unset=True)
    if not update_data:
        raise HTTPException(status_code=400, detail="No se enviaron datos para actualizar")
        
    set_clause = ", ".join([f"{k} = :{k}" for k in update_data.keys()])
    sql = text(f"UPDATE proparcon.persona SET {set_clause} WHERE id = :id RETURNING id")
    
    res = db.execute(sql, {**update_data, "id": persona_id}).first()
    if not res:
        raise HTTPException(status_code=404, detail="No se encontró la persona para actualizar")
        
    db.commit()
    return {"id": res[0], "status": "updated"}

# --- 5. ENDPOINTS DE ELIMINACIÓN (DELETE) ---

@router.delete("/{persona_id}")
def eliminar_persona(persona_id: int, db: Session = Depends(get_db)):
    """
    Elimina un registro de persona.
    """
    sql = text("DELETE FROM proparcon.persona WHERE id = :id")
    db.execute(sql, {"id": persona_id})
    db.commit()
    return {"message": "Registro eliminado correctamente"}

--- ARCHIVO: app\api\propiedad.py ---
"""
====================================================================
ARCHIVO: app/api/propiedad.py
PROYECTO: PROPARCON API
DESCRIPCIÓN: Gestión de titularidades (Persona Física - Inmueble).
====================================================================
ACTUALIZACIÓN REALIZADA:
    ✅ ALINEACIÓN DDL: Uso estricto de 'doc_identidad', 'nombre' y 
       'apellido1' según esquema confirmado.
    ✅ VISTA JERÁRQUICA: Consulta SQL optimizada para agrupar por 
       Inmueble, incluyendo la descripción del catálogo de derechos.
    ✅ CRUD COMPLETO: Sincronización de POST, GET, PATCH y DELETE.
====================================================================
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from app.api.deps import get_db

router = APIRouter()

# --- SECCIÓN 1: MODELOS PYDANTIC ---
class PropiedadCreate(BaseModel):
    inmueble_id: int
    persona_id: int
    tipo_derecho_id: int
    porcentaje: float = Field(..., ge=0, le=100)

class PropiedadUpdate(BaseModel):
    persona_id: Optional[int] = None
    tipo_derecho_id: Optional[int] = None
    porcentaje: Optional[float] = Field(None, ge=0, le=100)

# --- SECCIÓN 2: CONSULTAS (GET) ---
@router.get("", response_model=List[dict])
def listar_propiedades(db: Session = Depends(get_db)):
    """Lista titularidades para visualización jerárquica Inmueble -> Dueños."""
    sql = text("""
        SELECT 
            ip.id, ip.inmueble_id, ip.persona_id, ip.porcentaje, ip.tipo_derecho_id,
            i.nombre_publico as inmueble_nombre,
            (p.nombre || ' ' || p.apellido1) as titular_nombre,
            p.doc_identidad as titular_doc,
            td.descripcion as derecho_desc
        FROM proparcon.inmueble_propiedad ip
        JOIN proparcon.inmueble i ON ip.inmueble_id = i.id
        JOIN proparcon.persona p ON ip.persona_id = p.id
        JOIN proparcon.cat_tipo_derecho_propiedad td ON ip.tipo_derecho_id = td.id
        ORDER BY i.nombre_publico ASC, ip.porcentaje DESC
    """)
    res = db.execute(sql).mappings().all()
    return [dict(r) for r in res]

# --- SECCIÓN 3: ESCRITURA (POST / PATCH / DELETE) ---
@router.post("", status_code=status.HTTP_201_CREATED)
def crear_propiedad(datos: PropiedadCreate, db: Session = Depends(get_db)):
    sql = text("""
        INSERT INTO proparcon.inmueble_propiedad (inmueble_id, persona_id, tipo_derecho_id, porcentaje) 
        VALUES (:i, :p, :t, :po) RETURNING id
    """)
    res = db.execute(sql, {"i": datos.inmueble_id, "p": datos.persona_id, "t": datos.tipo_derecho_id, "po": datos.porcentaje}).first()
    db.commit()
    return {"id": res[0], "message": "Propiedad asignada"}

@router.patch("/{propiedad_id}")
def actualizar_propiedad(propiedad_id: int, datos: PropiedadUpdate, db: Session = Depends(get_db)):
    update_data = datos.model_dump(exclude_unset=True)
    if not update_data: raise HTTPException(400, "Sin cambios")
    set_clause = ", ".join([f"{k} = :{k}" for k in update_data.keys()])
    sql = text(f"UPDATE proparcon.inmueble_propiedad SET {set_clause} WHERE id = :id RETURNING id")
    db.execute(sql, {**update_data, "id": propiedad_id})
    db.commit()
    return {"id": propiedad_id, "status": "updated"}

@router.delete("/{propiedad_id}")
def eliminar_propiedad(propiedad_id: int, db: Session = Depends(get_db)):
    db.execute(text("DELETE FROM proparcon.inmueble_propiedad WHERE id = :id"), {"id": propiedad_id})
    db.commit()
    return {"message": "Registro eliminado"}

--- ARCHIVO: app\api\__init__.py ---
# app/api/__init__.py
# Se deja vacío para evitar importaciones circulares.

--- ARCHIVO: app\api\v1\endpoints\auth copy.py ---
"""
====================================================================
ARCHIVO: auth.py (REVISADO)
====================================================================
Descripción: Endpoint de Autenticación con logs de depuración.
Sección: Endpoint - Validación de credenciales.
====================================================================
"""
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from pydantic import BaseModel
from app.api.deps import get_db
from app.core.security import verify_password, create_access_token
from app.models.users import User

router = APIRouter()

class LoginRequest(BaseModel):
    email: str
    password: str

@router.post("/login")
def login_access_token(login_data: LoginRequest, db: Session = Depends(get_db)):
    # --- SECCIÓN: LOG DE ENTRADA ---
    print(f"Intento de login para: {login_data.email}")

    # 1. Buscar el usuario
    user = db.query(User).filter(User.email == login_data.email).first()
    
    # --- SECCIÓN: BYPASS DE DIAGNÓSTICO ---
    # Permitimos el acceso directo si es el admin conocido (sin importar .com o .es)
    emails_admin = ["admin@proparcon.es", "admin@proparcon.com"]
    
    if login_data.email in emails_admin and login_data.password == "admin":
        if not user:
            print(f"ERROR: El email {login_data.email} no existe en la base de datos.")
            raise HTTPException(status_code=404, detail="Usuario admin no existe en BD")
            
        print("Login exitoso vía BYPASS")
        token_data = {"sub": user.email, "role": user.role}
        return {
            "access_token": create_access_token(token_data),
            "token_type": "bearer"
        }

    # 2. Lógica Estándar si no entra por bypass
    if not user or not verify_password(login_data.password, user.password_hash):
        print("Fallo en verificación de contraseña o usuario inexistente")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales incorrectas"
        )

    token_data = {"sub": user.email, "role": user.role}
    return {
        "access_token": create_access_token(token_data),
        "token_type": "bearer"
    }

--- ARCHIVO: app\api\v1\endpoints\auth.py ---
"""
====================================================================
ARCHIVO: app/api/v1/endpoints/auth.py
PROYECTO: PROPARCON API
====================================================================

DESCRIPCIÓN:
    Endpoint de autenticación. Valida credenciales contra BD y emite JWT.

SEGURIDAD:
    - El "bypass" de admin (email en whitelist + password fija) es SOLO para
      desarrollo y queda DESHABILITADO por defecto.
    - Para habilitarlo, define:
        ADMIN_BYPASS_ENABLED=1
        ADMIN_BYPASS_EMAILS=admin@tu-dominio.com,otro@tu-dominio.com
        ADMIN_BYPASS_PASSWORD=admin   (o el valor que quieras)
====================================================================
"""

from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.core.security import create_access_token, verify_password
from app.models.users import User

logger = logging.getLogger(__name__)

router = APIRouter()


# -------------------------------------------------------------------
# MODELOS DE ENTRADA
# -------------------------------------------------------------------
class LoginRequest(BaseModel):
    email: EmailStr
    password: str


# -------------------------------------------------------------------
# CONFIG BYPASS (DEV ONLY) - DESHABILITADO POR DEFECTO
# -------------------------------------------------------------------
def _bypass_enabled() -> bool:
    return os.getenv("ADMIN_BYPASS_ENABLED", "0").strip() == "1"


def _bypass_password() -> str:
    return os.getenv("ADMIN_BYPASS_PASSWORD", "admin").strip()


def _bypass_emails() -> set[str]:
    raw = os.getenv("ADMIN_BYPASS_EMAILS", "").strip()
    if not raw:
        return set()
    return {e.strip().lower() for e in raw.split(",") if e.strip()}


def _get_user_by_email(db: Session, email: str) -> Optional[User]:
    return db.query(User).filter(User.email == email).first()


# -------------------------------------------------------------------
# ENDPOINT
# -------------------------------------------------------------------
@router.post("/login", tags=["auth"])
def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """
    Autentica un usuario y devuelve un access_token JWT.

    Devuelve:
      - access_token: JWT
      - token_type: "bearer"
    """
    email = login_data.email.lower().strip()

    # 1) BYPASS: SOLO si está habilitado por entorno (DEV)
    if _bypass_enabled():
        allowed_emails = _bypass_emails()
        if allowed_emails and email in allowed_emails and login_data.password == _bypass_password():
            user = _get_user_by_email(db, email)
            if not user:
                # Esto es deliberado: si la cuenta no existe, no “inventamos” usuarios.
                raise HTTPException(status_code=404, detail="Usuario bypass no existe en BD")

            token_data = {"sub": user.email, "role": user.role}
            logger.warning("Login BYPASS usado para email=%s", email)
            return {"access_token": create_access_token(token_data), "token_type": "bearer"}

    # 2) Login estándar (producción)
    user = _get_user_by_email(db, email)
    if not user or not verify_password(login_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales incorrectas",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token_data = {"sub": user.email, "role": user.role}
    return {"access_token": create_access_token(token_data), "token_type": "bearer"}


--- ARCHIVO: app\api\v1\endpoints\login_router.py ---
# app/api/v1/endpoints/login_router.py (o su archivo de login)

from typing import Optional # 🚨 CORRECCIÓN: Importar Optional
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm 
from sqlalchemy.orm import Session
from pydantic import BaseModel # 🚨 CORRECCIÓN: Importar BaseModel

# ====================================================================
# IMPORTACIONES CLAVE
# ====================================================================

from app.api.infra import get_db 
from app.core.security import verify_password, create_access_token 
from app.models.users import User # Importa el modelo de la tabla de usuarios

# Asumiendo que el modelo Token está definido aquí para evitar problemas de importación
class Token(BaseModel):
    access_token: str
    token_type: str
    role: str
    full_name: Optional[str] = None


router = APIRouter(tags=["authentication"])

@router.post("/auth/login", response_model=Token, summary="Genera token JWT para usuarios de aplicación")
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    # 1. Buscar usuario por email en la tabla DEDICADA 'users'
    user = db.query(User).filter(User.email == form_data.username).first()

    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inválidas o usuario inactivo",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 2. Verificar la contraseña hasheada
    if not verify_password(form_data.password, user.hashed_password): 
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Contraseña incorrecta",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # 3. Crear el token JWT
    access_token = create_access_token(
        data={
            "sub": user.email, 
            "role": user.role, 
            "user_id": str(user.id),
            "full_name": user.full_name 
        }
    )

    # 4. Devolver el token
    return Token(
        access_token=access_token, 
        token_type="bearer", 
        role=user.role,
        full_name=user.full_name
    )

--- ARCHIVO: app\api\v1\endpoints\users.py ---
"""
====================================================================
USERS.PY: Gestión de Cuentas de Acceso (Versión Full CRUD)
====================================================================
Secciones:
  1. Modelos Pydantic (Validación de entrada y esquemas de Update)
  2. Consulta de Usuarios (GET por ID / Me)
  3. Registro y Creación (POST) - Transaccional con persona_id
  4. Actualización Dinámica (PATCH)
  5. Eliminación Física (DELETE) - Limpieza de Ciclo
====================================================================
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy.orm import Session
from sqlalchemy.sql import text

from app.api.deps import get_db, RoleChecker, get_current_user
from app.core.security import get_password_hash
from app.models.users import User, UserRole

router = APIRouter()
admin_only = Depends(RoleChecker([UserRole.ADMIN]))

# --------------------------------------------------------------------
# SECCIÓN 1: MODELOS PYDANTIC
# --------------------------------------------------------------------

class UserCreate(BaseModel):
    id: str = Field(..., description="ID string (varchar 50)")
    persona_id: int
    email: EmailStr
    password: str = Field(..., min_length=4)
    role: UserRole = UserRole.LECTOR

class UserResponse(BaseModel):
    id: str
    persona_id: int
    email: EmailStr
    role: str
    is_active: bool

    class Config:
        from_attributes = True

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    role: Optional[UserRole] = None
    is_active: Optional[bool] = None

# --------------------------------------------------------------------
# SECCIÓN 2: CONSULTA (GET)
# --------------------------------------------------------------------

@router.get("/me", response_model=UserResponse)
def leer_perfil_propio(current_user: User = Depends(get_current_user)):
    return current_user

@router.get("/{user_id}", response_model=UserResponse, dependencies=[admin_only])
def obtener_usuario(user_id: str, db: Session = Depends(get_db)):
    sql = text("SELECT id, persona_id, email, role, is_active FROM proparcon.users WHERE id = :id")
    res = db.execute(sql, {"id": user_id}).mappings().first()
    if not res:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return res

# --------------------------------------------------------------------
# SECCIÓN 3: REGISTRO Y CREACIÓN (POST)
# --------------------------------------------------------------------

@router.post("", status_code=status.HTTP_201_CREATED, dependencies=[admin_only])
def crear_usuario_acceso(datos: UserCreate, db: Session = Depends(get_db)):
    """Crea un usuario vinculado a una persona_id."""
    hash_p = get_password_hash(datos.password)
    sql = text("""
        INSERT INTO proparcon.users (id, persona_id, email, password_hash, role)
        VALUES (:id, :p_id, :email, :pass, :role) RETURNING id
    """)
    try:
        res = db.execute(sql, {
            "id": datos.id, "p_id": datos.persona_id, 
            "email": datos.email, "pass": hash_p, "role": datos.role.value
        }).first()
        db.commit()
        return {"id": res[0], "message": "Acceso creado"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Error DDL Users: {str(e)}")

# --------------------------------------------------------------------
# SECCIÓN 4: ACTUALIZACIÓN DINÁMICA (PATCH)
# --------------------------------------------------------------------

@router.patch("/{user_id}", dependencies=[admin_only])
def actualizar_usuario(user_id: str, datos: UserUpdate, db: Session = Depends(get_db)):
    update_dict = datos.model_dump(exclude_unset=True)
    if not update_dict:
        raise HTTPException(400, "Sin cambios")
    
    set_clause = ", ".join([f"{k} = :{k}" for k in update_dict.keys()])
    sql = text(f"UPDATE proparcon.users SET {set_clause} WHERE id = :id RETURNING id")
    
    try:
        res = db.execute(sql, {**update_dict, "id": user_id}).first()
        db.commit()
        return {"id": res[0], "status": "updated"}
    except Exception as e:
        db.rollback()
        raise HTTPException(400, detail=str(e))

# --------------------------------------------------------------------
# SECCIÓN 5: ELIMINACIÓN FÍSICA (DELETE)
# --------------------------------------------------------------------

@router.delete("/{user_id}", dependencies=[admin_only])
def borrar_usuario_fisico(user_id: str, db: Session = Depends(get_db)):
    sql = text("DELETE FROM proparcon.users WHERE id = :id RETURNING id")
    try:
        res = db.execute(sql, {"id": user_id}).first()
        db.commit()
        return {"id": res[0] if res else None, "message": "Acceso eliminado"}
    except Exception as e:
        db.rollback()
        raise HTTPException(400, detail=str(e))

--- ARCHIVO: app\api\v1\endpoints\__init__.py ---


--- ARCHIVO: app\auth\auth_bearer.py ---
# app/auth/auth_bearer.py
from typing import List, Optional
from fastapi import Request, HTTPException, Depends 
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt 

JWT_SECRET = "secret_key_proparcon_123" 
JWT_ALGORITHM = "HS256"

class JWTBearer(HTTPBearer):
    async def __call__(self, request: Request):
        credentials = await super(JWTBearer, self).__call__(request)
        if credentials:
            payload = jwt.decode(credentials.credentials, JWT_SECRET, algorithms=[JWT_ALGORITHM])
            if not payload:
                raise HTTPException(status_code=403, detail="Token inválido")
            return credentials.credentials
        raise HTTPException(status_code=403, detail="No autorizado")

class RoleChecker:
    def __init__(self, required_roles: List[str]):
        self.required_roles = required_roles
    def __call__(self, request: Request, token: str = Depends(JWTBearer())): 
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        user_roles = payload.get("roles", [])
        if "ADMIN" in user_roles or set(self.required_roles).intersection(set(user_roles)):
            return True
        raise HTTPException(status_code=403, detail="Permisos insuficientes")

--- ARCHIVO: app\auth\__init__.py ---


--- ARCHIVO: app\core\auth_deps.py ---
# app/core/auth_deps.py
# Contiene la lógica para obtener el usuario actual y verificar roles (RoleChecker).

from typing import Optional, List, Annotated, Dict, Any
from fastapi import Depends, HTTPException, status, Security
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from jose import JWTError, jwt
from pydantic import BaseModel, EmailStr

# Importaciones CLAVE
from app.api.infra import get_db 
from app.core.security import oauth2_scheme, SECRET_KEY, ALGORITHM # De tu security.py

# -------------------------------------------------------------------
# SCHEMAS DE AUTORIZACIÓN
# -------------------------------------------------------------------

class CurrentUser(BaseModel):
    """Modelo inyectado que representa el usuario autenticado."""
    id: int
    email: EmailStr
    roles: List[str] # Lista de códigos de roles (e.g., ['ADMIN', 'GESTOR'])
    nombre: str
    apellido1: str

# -------------------------------------------------------------------
# DEPENDENCIAS DE AUTORIZACIÓN
# -------------------------------------------------------------------

# (La función get_persona_data_from_db se movería aquí o se haría inline)

# Configuración síncrona)
def get_current_persona(token: Annotated[str, Depends(oauth2_scheme)], db: Session = Depends(get_db)) -> CurrentUser: 
    """Decodifica el JWT, verifica la validez y retorna el objeto CurrentUser."""
    
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Token inválido o expirado",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        # Decodificar el token
        payload: Dict[str, Any] = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        
        # Asumiendo que el token tiene 'persona_id' y 'roles'
        persona_id: Optional[int] = payload.get("persona_id")
        roles: Optional[List[str]] = payload.get("roles")

        if persona_id is None or roles is None:
            raise credentials_exception
        
    except JWTError:
        raise credentials_exception
    
    # 📌 RECARGA DE DATOS (Mismo query que en tu persona.py)
    sql_current_user = text("""
        SELECT p.id, p.email_particular, p.nombre, p.apellido1
        FROM proparcon.persona p
        WHERE p.id = :id;
    """)
    persona_row = db.execute(sql_current_user, {"id": persona_id}).mappings().first()
    
    if persona_row is None:
        raise credentials_exception 
        
    return CurrentUser(
        id=persona_row["id"],
        email=persona_row["email_particular"],
        roles=roles, 
        nombre=persona_row["nombre"],
        apellido1=persona_row["apellido1"]
    )

class RoleChecker:
    """Clase dependiente que verifica si el usuario autenticado tiene uno de los roles requeridos."""
    
    def __init__(self, required_roles: List[str]):
        self.required_roles = required_roles

    def __call__(self, current_persona: CurrentUser = Security(get_current_persona)) -> CurrentUser:
        
        if not self.required_roles:
            return current_persona 
            
        has_permission = any(role in current_persona.roles for role in self.required_roles)

        if not has_permission:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="No tiene permisos suficientes. Roles requeridos: " + ", ".join(self.required_roles),
            )
            
        return current_persona

--- ARCHIVO: app\core\db.py ---
# app/core/db.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from .settings import settings

# ==============================================================================
# 0. BASE DECLARATIVA (Soluciona el NameError: name 'Base' is not defined)
# ==============================================================================
# Definir Base aquí centraliza los modelos y permite que 'users.py' la importe.
Base = declarative_base()

# ==============================================================================
# 1. PARTE ASÍNCRONA (Para módulos modernos como Users)
# ==============================================================================
ASYNC_DATABASE_URL = settings.database_url_async

engine_async = create_async_engine(
    ASYNC_DATABASE_URL,
    echo=False,
    future=True,
    pool_pre_ping=True
)

AsyncSessionLocal = async_sessionmaker(
    bind=engine_async,
    class_=AsyncSession,
    autoflush=False,
    expire_on_commit=False
)

async def prepare_session_search_path_async(db: AsyncSession) -> None:
    """Configura el esquema para sesiones asíncronas"""
    if settings.POSTGRES_SCHEMA:
        await db.execute(text(f"SET search_path TO {settings.POSTGRES_SCHEMA}, public"))

# Inyección de dependencia para endpoints ASÍNCRONOS
async def get_async_db():
    async with AsyncSessionLocal() as session:
        try:
            await prepare_session_search_path_async(session)
            yield session
        finally:
            await session.close()


# ==============================================================================
# 2. PARTE SÍNCRONA (Para Auth, Inmueble, Oferta, Contrato y Postman Tests)
# ==============================================================================
# Se construye la URL para psycopg2 (síncrono)
SYNC_DATABASE_URL = (
    f"postgresql+psycopg2://{settings.POSTGRES_USER}:{settings.POSTGRES_PASSWORD}"
    f"@{settings.POSTGRES_HOST}:{settings.POSTGRES_PORT}/{settings.POSTGRES_DB}"
)

engine_sync = create_engine(
    SYNC_DATABASE_URL,
    pool_pre_ping=True,
    future=True
)

SessionLocal = sessionmaker(
    bind=engine_sync,
    autoflush=False,
    autocommit=False,
    expire_on_commit=False,
    class_=Session
)

def prepare_session_search_path(db: Session) -> None:
    """Configura el esquema para sesiones síncronas"""
    if settings.POSTGRES_SCHEMA:
        db.execute(text(f"SET search_path TO {settings.POSTGRES_SCHEMA}, public"))
        db.commit() # Asegura que el search_path se aplique a la transacción actual

# Inyección de dependencia para endpoints SÍNCRONOS (Usada por auth.py)
def get_db():
    db = SessionLocal()
    try:
        prepare_session_search_path(db)
        yield db
    finally:
        db.close()

--- ARCHIVO: app\core\dependencies.py ---
"""
PROPARCON API - Dependencias de Núcleo
======================================
Ubicación: app/core/dependencies.py

Descripción:
------------
Gestiona la inyección de dependencias para las sesiones de base de datos.
Soporta tanto operaciones síncronas (Legacy/Auth) como asíncronas (Users).
"""

from typing import List, Dict, Any, Generator, AsyncGenerator
from sqlalchemy.orm import Session
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.sql import text

# Importamos las herramientas desde nuestro db.py actualizado
from app.core.db import (
    SessionLocal, 
    AsyncSessionLocal, 
    prepare_session_search_path,
    prepare_session_search_path_async
)

# =============================================================================
# SECCIÓN 1: DEPENDENCIAS DE BASE DE DATOS
# =============================================================================

def get_db() -> Generator[Session, None, None]:
    """
    Obtiene una sesión SÍNCRONA. 
    Uso: Requerida por auth.py para el 'Test 01 - Login'.
    """
    db = SessionLocal()
    try:
        # El search_path se aplica dentro de la función importada de db.py
        prepare_session_search_path(db)
        yield db
    finally:
        db.close()

async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Obtiene una sesión ASÍNCRONA.
    Uso: Requerida por la creación de usuarios y endpoints modernos.
    """
    async with AsyncSessionLocal() as session:
        try:
            await prepare_session_search_path_async(session)
            yield session
        finally:
            await session.close()

# =============================================================================
# SECCIÓN 2: UTILIDADES DE DATOS
# =============================================================================

def rows_to_dicts(result) -> List[Dict[str, Any]]:
    """Convierte un Result de SQLAlchemy en lista de diccionarios."""
    return [dict(r._mapping) for r in result.fetchall()]

def _fk_exists(db: Session, table: str, pk_id: int) -> bool:
    """
    Comprueba existencia de una Clave Foránea en una tabla específica.
    Utiliza el search_path configurado en la sesión.
    """
    # Nota: Asegúrate de que 'table' incluya el esquema si no se usa search_path
    query = text(f"SELECT 1 FROM {table} WHERE id = :id")
    row = db.execute(query, {"id": pk_id}).first()
    return bool(row)

--- ARCHIVO: app\core\security.py ---
"""
====================================================================
SECURITY.PY: Criptografía y Gestión de Tokens (Versión Enterprise)
====================================================================
Estado: ✅ Corregido y Validado
"""
import os
from datetime import datetime, timedelta, timezone
from typing import Union, Any
from jose import jwt
from passlib.context import CryptContext
from fastapi.security import OAuth2PasswordBearer

# 1. CONFIGURACIÓN GLOBAL (Requerida por deps.py)
# --------------------------------------------------------------------
SECRET_KEY = os.getenv("SECRET_KEY", "proparcon_secret_2025")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # 24 horas para facilitar tests

# Este objeto es el que busca FastAPI en los Headers (Authorization: Bearer <token>)
# La ruta debe coincidir con tu endpoint de login
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="v1/auth/login")

# 2. HASHING (Fix para error 'module bcrypt has no attribute __about__')
# --------------------------------------------------------------------
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Valida la contraseña contra el hash de la BD."""
    try:
        # Validación de seguridad: Bcrypt requiere 60 caracteres exactos
        if not hashed_password or len(hashed_password) != 60:
            return False
        return pwd_context.verify(plain_password, hashed_password)
    except Exception:
        return False

def get_password_hash(password: str) -> str:
    """Genera hash seguro para nuevos registros."""
    return pwd_context.hash(password)

# 3. GENERACIÓN DE TOKENS
# --------------------------------------------------------------------
def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None) -> str:
    """Genera el JWT que Postman capturará en el Test 01."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

--- ARCHIVO: app\core\settings.py ---
# app/core/settings.py
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List

class Settings(BaseSettings):
    # --- Configuración de Base de Datos ---
    POSTGRES_DB: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_HOST: str = "localhost"
    POSTGRES_PORT: int = 5432
    POSTGRES_SCHEMA: str = "public"

    # --- Configuración de Seguridad (JWT para Roles) ---
    # Importante: Cambia esto en producción por una cadena larga y aleatoria
    SECRET_KEY: str = "super_secret_key_change_me_in_production_12345"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # --- Configuración CORS (Para React) ---
    # Permite peticiones desde estos orígenes (ej. tu frontend en localhost:3000)
    BACKEND_CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://localhost:5173"]

    # --- Configuración General del Proyecto ---
    PROJECT_NAME: str = "Gestión de Alquileres"
    
    # Esta configuración permite leer automáticamente el archivo .env
    model_config = SettingsConfigDict(
        env_file=".env", 
        env_file_encoding="utf-8", 
        case_sensitive=True,
        extra="ignore" # Ignora variables extra en el .env que no estén aquí definidas
    )

    @property
    def database_url_async(self) -> str:
        """Genera la URL de conexión para AsyncPG"""
        return (f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}"
                f"@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}")

settings = Settings()

--- ARCHIVO: app\models\base.py ---
from typing import Any
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy.orm import DeclarativeBase
from app.core.settings import settings

class Base(DeclarativeBase):
    id: Any  # Placeholder para el tipado, se definirá en cada modelo

    # Genera automáticamente el nombre de la tabla __tablename__ basado en el nombre de la clase
    # Ejemplo: clase 'User' -> tabla 'users'
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + "s"

    # Forzar que todas las tablas se creen en el esquema configurado (ej: 'proparcon')
    # Si settings.POSTGRES_SCHEMA es None o 'public', usa el esquema por defecto.
    @declared_attr
    def __table_args__(cls):
        return {"schema": settings.POSTGRES_SCHEMA} if settings.POSTGRES_SCHEMA else {}

--- ARCHIVO: app\models\users copy.py ---
"""
====================================================================
MODELS/USERS.PY: Definición de Identidad (Sincronizado con DDL)
====================================================================
Secciones:
  1. Enums de Usuario (Sincronizado con 'role' varchar)
  2. Definición de Clase User (Esquema proparcon)
  3. Columnas de Seguridad (password_hash)
  4. Atributos de Auditoría (fecha_creacion)
  5. Relaciones con Persona
====================================================================
"""

from sqlalchemy import Column, Integer, String, Boolean, BigInteger, DateTime, func
from enum import Enum
from app.core.db import Base

# 1. ENUMS DE USUARIO
class UserRole(str, Enum):
    """Roles definidos en el DDL (por defecto 'lector')."""
    ADMIN = "admin"
    GESTOR = "gestor"
    LECTOR = "lector"

# 2. DEFINICIÓN DE CLASE USER
class User(Base):
    """
    Modelo SQLAlchemy sincronizado con la tabla proparcon.users.
    """
    __tablename__ = "users"
    __table_args__ = {"schema": "proparcon"}

    # 3. COLUMNAS DE SEGURIDAD Y DATOS (Sincronizado con DDL)
    id = Column(String(50), primary_key=True, nullable=False) # varchar(50)
    persona_id = Column(BigInteger, unique=True, nullable=False) # int8
    email = Column(String(255), unique=True, nullable=False) # varchar(255)
    
    # 📌 CORRECCIÓN: nombre exacto del DDL
    password_hash = Column(String(255), nullable=False) 
    
    is_active = Column(Boolean, default=True, nullable=False)
    role = Column(String(20), default="lector", nullable=False)
    
    # 4. ATRIBUTOS DE AUDITORÍA
    fecha_creacion = Column(DateTime, server_default=func.now())

    # --------------------------------------------------------------------
    # SECCIÓN 4: MÉTODOS DE INSTANCIA
    # --------------------------------------------------------------------
    def __repr__(self):
        return f"<User(email={self.email}, role={self.role})>"

--- ARCHIVO: app\models\users.py ---
"""
====================================================================
MODELS/USERS.PY: Definición de Identidad (Sincronizado con DDL)
====================================================================
"""

from sqlalchemy import Column, String, Boolean, BigInteger, DateTime, func
from enum import Enum
from app.core.db import Base

# --------------------------------------------------------------------
# ENUM DE ROLES (LÓGICO, NO SQLALCHEMY)
# --------------------------------------------------------------------
class UserRole(str, Enum):
    """
    Roles definidos en el DDL (almacenados como varchar en BD).
    """
    ADMIN = "admin"
    GESTOR = "gestor"
    LECTOR = "lector"


class User(Base):
    """
    Modelo SQLAlchemy sincronizado con la tabla proparcon.users.
    """
    __tablename__ = "users"
    __table_args__ = {"schema": "proparcon"}

    id = Column(String(50), primary_key=True, nullable=False)
    persona_id = Column(BigInteger, unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)

    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)

    # Rol almacenado como STRING (admin | gestor | lector)
    role = Column(String(20), default=UserRole.LECTOR.value, nullable=False)

    fecha_creacion = Column(DateTime, server_default=func.now())

    def __repr__(self):
        return f"<User(email={self.email}, role={self.role})>"


--- ARCHIVO: app\models\__init__.py ---
"""
====================================================================
ARCHIVO: app/models/__init__.py
PROYECTO: PROPARCON API
DESCRIPCIÓN:
    Punto único de exportación del paquete de modelos SQLAlchemy.

REGLAS:
    - Solo se importan modelos que existen en app/models para no romper
      imports ni migraciones.
    - Base se exporta para que Alembic y tooling puedan acceder a metadata.
====================================================================
"""

# -------------------------------------------------------------------
# SECCIÓN 1: Base declarativa
# -------------------------------------------------------------------
from .base import Base

# -------------------------------------------------------------------
# SECCIÓN 2: Modelos disponibles en el paquete (según directorio actual)
# -------------------------------------------------------------------
from .users import User

__all__ = [
    "Base",
    "User",
]


--- ARCHIVO: app\routers\api copy.py ---
"""
Archivo: app/routers/api.py (NUEVO O REFACTORIZADO)
Descripción: Agregador de rutas con aplicación de políticas RBAC por módulo.
"""
from fastapi import APIRouter, Depends
from app.routers import auth, inmueble, persona, propiedad, estancia, oferta, contrato
from app.api.deps import RoleChecker
from app.models.users import UserRole

api_router = APIRouter()

# --- RUTAS PÚBLICAS ---
api_router.include_router(auth.router, prefix="/auth")

# --- RUTAS NIVEL GESTOR / ADMIN ---
# Inmuebles, Estancias y Ofertas pueden ser gestionados por Gestores
api_router.include_router(
    inmueble.router, 
    prefix="/inmueble",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN, UserRole.GESTOR]))]
)
api_router.include_router(
    estancia.router, 
    prefix="/estancia",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN, UserRole.GESTOR]))]
)
api_router.include_router(
    oferta.router, 
    prefix="/oferta",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN, UserRole.GESTOR]))]
)

# --- RUTAS NIVEL SOLO ADMIN ---
# Personas, Propiedades y Contratos son críticos (Cumplimiento legal/financiero)
api_router.include_router(
    persona.router, 
    prefix="/persona",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN]))]
)
api_router.include_router(
    propiedad.router, 
    prefix="/propiedad",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN]))]
)
api_router.include_router(
    contrato.router, 
    prefix="/contrato",
    dependencies=[Depends(RoleChecker([UserRole.ADMIN]))]
)

# Nueva versión: 48 líneas aprox.

--- ARCHIVO: app\routers\api.py ---
"""====================================================================
ARCHIVO: app/routers/api.py
PROYECTO: PROPARCON API
DESCRIPCIÓN:
    Agregador de routers funcionales (dominio) para FastAPI, aplicando RBAC.

CRITERIO DE DISEÑO:
    - Solo se incluyen routers de dominio (app/api/*.py).
    - Auth y Users se exponen EXCLUSIVAMENTE como endpoints versionados
      desde main.py (/v1/auth, /v1/users).
    - RBAC se aplica a nivel de include_router() para reducir boilerplate.
    - Catálogos (CRUD de administración) se protege por ADMIN.
===================================================================="""

from __future__ import annotations

from fastapi import APIRouter, Depends

# -------------------------------------------------------------------
# SECCIÓN 1: Dependencias de autorización (RBAC)
# -------------------------------------------------------------------
from app.api.deps import RoleChecker
from app.models.users import UserRole

# -------------------------------------------------------------------
# SECCIÓN 2: Routers de dominio (app/api/*.py)
# Nota: cada módulo debe exponer: router = APIRouter()
# -------------------------------------------------------------------
from app.api import (
    catalogos,
    contrato,
    estancia,
    infra,
    inmueble,
    oferta,
    persona,
    propiedad,
)

# -------------------------------------------------------------------
# SECCIÓN 3: Router maestro
# -------------------------------------------------------------------
api_router = APIRouter()

# -------------------------------------------------------------------
# SECCIÓN 4: RUTAS PÚBLICAS / INFRA
# -------------------------------------------------------------------
api_router.include_router(
    infra.router,
    prefix="/infra",
    tags=["infra"],
)

# -------------------------------------------------------------------
# SECCIÓN 5: CATÁLOGOS (ADMIN)
# - Menú de administración CRUD: requiere token y rol ADMIN
# -------------------------------------------------------------------
admin_only = Depends(RoleChecker([UserRole.ADMIN]))

api_router.include_router(
    catalogos.router,
    prefix="/catalogos",
    tags=["catalogos"],
    dependencies=[admin_only],
)

# -------------------------------------------------------------------
# SECCIÓN 6: RUTAS CON RBAC: GESTOR o ADMIN
# -------------------------------------------------------------------
gestor_or_admin = Depends(RoleChecker([UserRole.ADMIN, UserRole.GESTOR]))

api_router.include_router(
    inmueble.router,
    prefix="/inmueble",
    tags=["inmueble"],
    dependencies=[gestor_or_admin],
)

api_router.include_router(
    estancia.router,
    prefix="/estancia",
    tags=["estancia"],
    dependencies=[gestor_or_admin],
)

api_router.include_router(
    oferta.router,
    prefix="/oferta",
    tags=["oferta"],
    dependencies=[gestor_or_admin],
)

# -------------------------------------------------------------------
# SECCIÓN 7: RUTAS CON RBAC: SOLO ADMIN
# -------------------------------------------------------------------
api_router.include_router(
    persona.router,
    prefix="/persona",
    tags=["persona"],
    dependencies=[admin_only],
)

api_router.include_router(
    propiedad.router,
    prefix="/propiedad",
    tags=["propiedad"],
    dependencies=[admin_only],
)

api_router.include_router(
    contrato.router,
    prefix="/contrato",
    tags=["contrato"],
    dependencies=[admin_only],
)

__all__ = ["api_router"]


--- ARCHIVO: app\schemas\auth.py ---
"""
Archivo: app/schemas/auth.py
Descripción: Modelos de Pydantic para el flujo de autenticación y tokens.
"""
from typing import Optional
from pydantic import BaseModel, EmailStr

class Token(BaseModel):
    """Respuesta estándar tras un login exitoso."""
    access_token: str
    token_type: str
    # Agregamos info básica del usuario para evitar decodificar el JWT en el Front
    user_email: EmailStr
    user_role: str

class TokenPayload(BaseModel):
    """Estructura interna del contenido del token JWT."""
    sub: Optional[str] = None # Generalmente el email
    role: Optional[str] = None
    user_id: Optional[int] = None

class LoginRequest(BaseModel):
    """Esquema para la petición de login (JSON body)."""
    email: EmailStr
    password: str

# Nueva versión: 28 líneas.}

--- ARCHIVO: app\schemas\users.py ---
from pydantic import BaseModel, EmailStr
from datetime import datetime

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    is_active: bool
    persona_id: int
    fecha_creacion: datetime

    class Config:
        from_attributes = True

--- ARCHIVO: sql\01_catalogos.sql ---
-- Esquema base (si hiciera falta recrearlo manualmente)
-- DROP SCHEMA IF EXISTS proparcon CASCADE;
-- CREATE SCHEMA proparcon AUTHORIZATION CURRENT_USER;

CREATE TABLE proparcon.cat_tipo_via (
  id  integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(20) UNIQUE NOT NULL,
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_pais (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  iso2 char(2) UNIQUE NOT NULL,
  nombre text NOT NULL
);

CREATE TABLE proparcon.cat_provincia (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  pais_id integer NOT NULL REFERENCES proparcon.cat_pais(id),
  nombre text NOT NULL,
  UNIQUE (pais_id, nombre)
);

CREATE TABLE proparcon.cat_rol (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_tipo_inmueble (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_tipo_estancia (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,
  descripcion text NOT NULL,
  alquilable boolean NOT NULL DEFAULT false,
  es_raiz boolean NOT NULL DEFAULT false
);

CREATE TABLE proparcon.cat_tipo_derecho_propiedad (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- USUFRUCTO, NUDA, PLENO
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_estado_oferta_alquiler (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- VACIO, RESERVADO, EN_OBRA
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_tipo_avaliador (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- PERSONA, SEGURO_IMPAGO, AVAL_BANCARIO
  descripcion text NOT NULL
);

CREATE TABLE proparcon.cat_tipo_ingreso (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- NOMINA, NOMINA_B, ...
  descripcion text NOT NULL
);


--- ARCHIVO: sql\021_Core_More.sql ---
-- DIRECCION
CREATE TABLE proparcon.direccion (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_via_id integer REFERENCES proparcon.cat_tipo_via(id),
  via_nombre text NOT NULL,
  numero varchar(10),
  escalera varchar(10),
  piso varchar(10),
  puerta varchar(10),
  cp varchar(10),
  municipio text,
  provincia_id integer REFERENCES proparcon.cat_provincia(id),
  pais_id integer REFERENCES proparcon.cat_pais(id),
  observaciones text
);

-- PERSONA / JURIDICA (sin dominios; checks in-line)
CREATE TABLE proparcon.persona (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_doc varchar(20) NOT NULL,
  doc_identidad text NOT NULL CHECK (length(doc_identidad) BETWEEN 3 AND 64),
  nombre text NOT NULL,
  apellido1 text NOT NULL,
  apellido2 text,
  fecha_nacimiento date,
  lugar_nacimiento text,
  nacionalidad text,
  profesion text,
  direccion_id bigint REFERENCES proparcon.direccion(id),
  telefono_fijo varchar(25),
  telefono_movil varchar(25),
  email_particular text,
  email_laboral text,
  nick text,
  linkedin text,
  iban text,
  UNIQUE (tipo_doc, doc_identidad)
);

CREATE TABLE proparcon.juridica (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  cif varchar(20) UNIQUE NOT NULL,
  denominacion_social text NOT NULL,
  abreviatura varchar(10),
  domicilio_fiscal_id bigint REFERENCES proparcon.direccion(id),
  acta_titularidad_real date
);

-- ORGANO ADMIN
CREATE TABLE proparcon.org_admin_tipo (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- ADM_UNICO, SOLIDARIOS, MANCOMUNADOS, CONSEJO
  descripcion text NOT NULL
);

CREATE TABLE proparcon.org_admin (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  tipo_id integer NOT NULL REFERENCES proparcon.org_admin_tipo(id),
  fecha_escritura date
);

CREATE TABLE proparcon.org_admin_miembro (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  org_admin_id bigint NOT NULL REFERENCES proparcon.org_admin(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  representante_persona_id bigint REFERENCES proparcon.persona(id),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- EMPLEO
CREATE TABLE proparcon.centro_trabajo (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  direccion_id bigint NOT NULL REFERENCES proparcon.direccion(id)
);

CREATE TABLE proparcon.empleado (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  persona_id bigint NOT NULL REFERENCES proparcon.persona(id) ON DELETE CASCADE,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  centro_trabajo_id bigint REFERENCES proparcon.centro_trabajo(id),
  UNIQUE (persona_id, juridica_id)
);

-- ROLES
CREATE TABLE proparcon.persona_rol (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  persona_id bigint NOT NULL REFERENCES proparcon.persona(id) ON DELETE CASCADE,
  rol_id integer NOT NULL REFERENCES proparcon.cat_rol(id),
  gestor_supervisor_id bigint REFERENCES proparcon.persona(id),
  fecha_alta date DEFAULT now(),
  fecha_baja date,
  UNIQUE (persona_id, rol_id)
);

-- INMUEBLE
CREATE TABLE proparcon.inmueble (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_inmueble_id integer NOT NULL REFERENCES proparcon.cat_tipo_inmueble(id),
  nombre_publico text,
  direccion_id bigint REFERENCES proparcon.direccion(id),
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  gestoria_juridica_id bigint REFERENCES proparcon.juridica(id)
);

CREATE TABLE proparcon.estancia (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  tipo_estancia_id integer NOT NULL REFERENCES proparcon.cat_tipo_estancia(id),
  nombre text,
  parent_estancia_id bigint REFERENCES proparcon.estancia(id),
  UNIQUE (inmueble_id, nombre)
);

-- REGISTRO & CATASTRO
CREATE TABLE proparcon.registro_propiedad (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL UNIQUE REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  localidad text NOT NULL,
  registro_numero text NOT NULL,
  seccion text,
  finca text NOT NULL,
  cru_idufir text UNIQUE,
  arp_fecha date,
  nota_simple_url text
);

CREATE TABLE proparcon.catastro (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL UNIQUE REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  ref_catastral varchar(20) UNIQUE NOT NULL,
  direccion_catastral_id bigint REFERENCES proparcon.direccion(id),
  uso text,
  anio_construccion int,
  coef_participacion numeric(5,2) CHECK (coef_participacion BETWEEN 0 AND 100),
  sup_construida numeric(10,2),
  sup_parcela numeric(10,2)
);

-- PROPIEDAD
CREATE TABLE proparcon.inmueble_propiedad (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  tipo_derecho_id integer NOT NULL REFERENCES proparcon.cat_tipo_derecho_propiedad(id),
  porcentaje numeric(5,2) NOT NULL CHECK (porcentaje BETWEEN 0 AND 100),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- ALQUILER
CREATE TABLE proparcon.alquiler_oferta (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  estancia_id bigint NOT NULL REFERENCES proparcon.estancia(id) ON DELETE CASCADE,
  estado_id integer NOT NULL REFERENCES proparcon.cat_estado_oferta_alquiler(id),
  renta_mensual numeric(12,2) NOT NULL CHECK (renta_mensual >= 0),
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  fecha_alta date NOT NULL DEFAULT now(),
  fecha_baja date
);

CREATE TABLE proparcon.alquiler_contrato (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  estancia_id bigint NOT NULL REFERENCES proparcon.estancia(id) ON DELETE CASCADE,
  fecha_inicio date NOT NULL,
  fecha_fin date,
  contrato_pdf_url text,
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  renta_mensual numeric(12,2) NOT NULL CHECK (renta_mensual >= 0),
  activo boolean NOT NULL DEFAULT true
);

CREATE TABLE proparcon.alquiler_contrato_inquilino (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  contrato_id bigint NOT NULL REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- AVAL
CREATE TABLE proparcon.entidad_bancaria (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  nombre text NOT NULL,
  cod_banco_esp char(4),
  swift_bic varchar(11)
);

CREATE TABLE proparcon.alquiler_contrato_aval (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  contrato_id bigint NOT NULL REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE,
  tipo_avaliador_id integer NOT NULL REFERENCES proparcon.cat_tipo_avaliador(id),
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  entidad_bancaria_id bigint REFERENCES proparcon.entidad_bancaria(id),
  importe_maximo numeric(12,2),
  plazo_meses int,
  detalles text,
  CHECK (
    (tipo_avaliador_id IS NOT NULL) AND
    (
      (persona_id IS NOT NULL AND juridica_id IS NULL)
      OR (persona_id IS NULL AND juridica_id IS NOT NULL)
      OR (entidad_bancaria_id IS NOT NULL)
    )
  )
);


--- ARCHIVO: sql\02_core.sql ---
-- DIRECCION
CREATE TABLE proparcon.direccion (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_via_id integer REFERENCES proparcon.cat_tipo_via(id),
  via_nombre text NOT NULL,
  numero varchar(10),
  escalera varchar(10),
  piso varchar(10),
  puerta varchar(10),
  cp varchar(10),
  municipio text,
  provincia_id integer REFERENCES proparcon.cat_provincia(id),
  pais_id integer REFERENCES proparcon.cat_pais(id),
  observaciones text
);

-- PERSONA / JURIDICA (sin dominios; checks in-line)
CREATE TABLE proparcon.persona (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_doc varchar(20) NOT NULL,
  doc_identidad text NOT NULL CHECK (length(doc_identidad) BETWEEN 3 AND 64),
  nombre text NOT NULL,
  apellido1 text NOT NULL,
  apellido2 text,
  fecha_nacimiento date,
  lugar_nacimiento text,
  nacionalidad text,
  profesion text,
  direccion_id bigint REFERENCES proparcon.direccion(id),
  telefono_fijo varchar(25),
  telefono_movil varchar(25),
  email_particular text,
  email_laboral text,
  nick text,
  linkedin text,
  iban text,
  UNIQUE (tipo_doc, doc_identidad)
);

CREATE TABLE proparcon.juridica (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  cif varchar(20) UNIQUE NOT NULL,
  denominacion_social text NOT NULL,
  abreviatura varchar(10),
  domicilio_fiscal_id bigint REFERENCES proparcon.direccion(id),
  acta_titularidad_real date
);

-- ORGANO ADMIN
CREATE TABLE proparcon.org_admin_tipo (
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  codigo varchar(40) UNIQUE NOT NULL,  -- ADM_UNICO, SOLIDARIOS, MANCOMUNADOS, CONSEJO
  descripcion text NOT NULL
);

CREATE TABLE proparcon.org_admin (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  tipo_id integer NOT NULL REFERENCES proparcon.org_admin_tipo(id),
  fecha_escritura date
);

CREATE TABLE proparcon.org_admin_miembro (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  org_admin_id bigint NOT NULL REFERENCES proparcon.org_admin(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  representante_persona_id bigint REFERENCES proparcon.persona(id),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- EMPLEO
CREATE TABLE proparcon.centro_trabajo (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  direccion_id bigint NOT NULL REFERENCES proparcon.direccion(id)
);

CREATE TABLE proparcon.empleado (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  persona_id bigint NOT NULL REFERENCES proparcon.persona(id) ON DELETE CASCADE,
  juridica_id bigint NOT NULL REFERENCES proparcon.juridica(id) ON DELETE CASCADE,
  centro_trabajo_id bigint REFERENCES proparcon.centro_trabajo(id),
  UNIQUE (persona_id, juridica_id)
);

-- ROLES
CREATE TABLE proparcon.persona_rol (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  persona_id bigint NOT NULL REFERENCES proparcon.persona(id) ON DELETE CASCADE,
  rol_id integer NOT NULL REFERENCES proparcon.cat_rol(id),
  gestor_supervisor_id bigint REFERENCES proparcon.persona(id),
  fecha_alta date DEFAULT now(),
  fecha_baja date,
  UNIQUE (persona_id, rol_id)
);

-- INMUEBLE
CREATE TABLE proparcon.inmueble (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  tipo_inmueble_id integer NOT NULL REFERENCES proparcon.cat_tipo_inmueble(id),
  nombre_publico text,
  direccion_id bigint REFERENCES proparcon.direccion(id),
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  gestoria_juridica_id bigint REFERENCES proparcon.juridica(id)
);

CREATE TABLE proparcon.estancia (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  tipo_estancia_id integer NOT NULL REFERENCES proparcon.cat_tipo_estancia(id),
  nombre text,
  parent_estancia_id bigint REFERENCES proparcon.estancia(id),
  UNIQUE (inmueble_id, nombre)
);

-- REGISTRO & CATASTRO
CREATE TABLE proparcon.registro_propiedad (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL UNIQUE REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  localidad text NOT NULL,
  registro_numero text NOT NULL,
  seccion text,
  finca text NOT NULL,
  cru_idufir text UNIQUE,
  arp_fecha date,
  nota_simple_url text
);

CREATE TABLE proparcon.catastro (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL UNIQUE REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  ref_catastral varchar(20) UNIQUE NOT NULL,
  direccion_catastral_id bigint REFERENCES proparcon.direccion(id),
  uso text,
  anio_construccion int,
  coef_participacion numeric(5,2) CHECK (coef_participacion BETWEEN 0 AND 100),
  sup_construida numeric(10,2),
  sup_parcela numeric(10,2)
);

-- PROPIEDAD
CREATE TABLE proparcon.inmueble_propiedad (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  inmueble_id bigint NOT NULL REFERENCES proparcon.inmueble(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  tipo_derecho_id integer NOT NULL REFERENCES proparcon.cat_tipo_derecho_propiedad(id),
  porcentaje numeric(5,2) NOT NULL CHECK (porcentaje BETWEEN 0 AND 100),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- ALQUILER
CREATE TABLE proparcon.alquiler_oferta (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  estancia_id bigint NOT NULL REFERENCES proparcon.estancia(id) ON DELETE CASCADE,
  estado_id integer NOT NULL REFERENCES proparcon.cat_estado_oferta_alquiler(id),
  renta_mensual numeric(12,2) NOT NULL CHECK (renta_mensual >= 0),
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  fecha_alta date NOT NULL DEFAULT now(),
  fecha_baja date
);

CREATE TABLE proparcon.alquiler_contrato (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  estancia_id bigint NOT NULL REFERENCES proparcon.estancia(id) ON DELETE CASCADE,
  fecha_inicio date NOT NULL,
  fecha_fin date,
  contrato_pdf_url text,
  gestor_persona_id bigint REFERENCES proparcon.persona(id),
  encargado_persona_id bigint REFERENCES proparcon.persona(id),
  renta_mensual numeric(12,2) NOT NULL CHECK (renta_mensual >= 0),
  activo boolean NOT NULL DEFAULT true
);

CREATE TABLE proparcon.alquiler_contrato_inquilino (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  contrato_id bigint NOT NULL REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE,
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  CHECK (
    (persona_id IS NOT NULL AND juridica_id IS NULL)
    OR (persona_id IS NULL AND juridica_id IS NOT NULL)
  )
);

-- AVAL
CREATE TABLE proparcon.entidad_bancaria (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  nombre text NOT NULL,
  cod_banco_esp char(4),
  swift_bic varchar(11)
);

CREATE TABLE proparcon.alquiler_contrato_aval (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  contrato_id bigint NOT NULL REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE,
  tipo_avaliador_id integer NOT NULL REFERENCES proparcon.cat_tipo_avaliador(id),
  persona_id bigint REFERENCES proparcon.persona(id),
  juridica_id bigint REFERENCES proparcon.juridica(id),
  entidad_bancaria_id bigint REFERENCES proparcon.entidad_bancaria(id),
  importe_maximo numeric(12,2),
  plazo_meses int,
  detalles text,
  CHECK (
    (tipo_avaliador_id IS NOT NULL) AND
    (
      (persona_id IS NOT NULL AND juridica_id IS NULL)
      OR (persona_id IS NULL AND juridica_id IS NOT NULL)
      OR (entidad_bancaria_id IS NOT NULL)
    )
  )
);


--- ARCHIVO: sql\03_indices.sql ---
CREATE INDEX proparcon_idx_persona_doc           ON proparcon.persona (tipo_doc, doc_identidad);
CREATE INDEX proparcon_idx_persona_rol           ON proparcon.persona_rol (persona_id, rol_id);
CREATE INDEX proparcon_idx_inmueble_gestor       ON proparcon.inmueble (gestor_persona_id);
CREATE INDEX proparcon_idx_estancia_inmueble     ON proparcon.estancia (inmueble_id);
CREATE INDEX proparcon_idx_inm_prop_inmueble     ON proparcon.inmueble_propiedad(inmueble_id);
CREATE INDEX proparcon_idx_inm_prop_tipo         ON proparcon.inmueble_propiedad(tipo_derecho_id);
CREATE INDEX proparcon_idx_alq_oferta_estancia   ON proparcon.alquiler_oferta(estancia_id);
CREATE INDEX proparcon_idx_alq_contrato_estancia ON proparcon.alquiler_contrato(estancia_id);
CREATE INDEX proparcon_idx_alq_contrato_activo   ON proparcon.alquiler_contrato(activo);


--- ARCHIVO: sql\04_triggers.sql ---
-- 1) % de propiedad (PLENO suma con USUFRUCTO/NUDA)
CREATE OR REPLACE FUNCTION proparcon.trg_check_propiedades_100()
RETURNS trigger AS $$
DECLARE
  v_inmueble bigint;
  v_sum_usufructo numeric(7,2);
  v_sum_nuda numeric(7,2);
  v_sum_pleno numeric(7,2);
BEGIN
  IF TG_OP = 'DELETE' THEN v_inmueble := OLD.inmueble_id; ELSE v_inmueble := NEW.inmueble_id; END IF;

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_usufructo
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'USUFRUCTO';

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_nuda
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'NUDA';

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_pleno
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'PLENO';

  IF v_sum_pleno > 100 THEN
    RAISE EXCEPTION 'Pleno dominio (%.2f) excede 100%% en inmueble %', v_sum_pleno, v_inmueble;
  END IF;
  IF (v_sum_usufructo + v_sum_pleno) > 100 THEN
    RAISE EXCEPTION 'Usufructo+Pleno (%.2f) excede 100%% en inmueble %', (v_sum_usufructo + v_sum_pleno), v_inmueble;
  END IF;
  IF (v_sum_nuda + v_sum_pleno) > 100 THEN
    RAISE EXCEPTION 'Nuda+Pleno (%.2f) excede 100%% en inmueble %', (v_sum_nuda + v_sum_pleno), v_inmueble;
  END IF;

  RETURN COALESCE(NEW, OLD);
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_propiedades_100 ON proparcon.inmueble_propiedad;
CREATE TRIGGER trg_propiedades_100
AFTER INSERT OR UPDATE OR DELETE ON proparcon.inmueble_propiedad
FOR EACH STATEMENT EXECUTE FUNCTION proparcon.trg_check_propiedades_100();

-- 2) Helper
CREATE OR REPLACE FUNCTION proparcon.fn_inmueble_de_estancia(in_estancia_id bigint)
RETURNS bigint AS $$
DECLARE v_inmueble_id bigint;
BEGIN
  SELECT e.inmueble_id INTO v_inmueble_id FROM proparcon.estancia e WHERE e.id = in_estancia_id;
  RETURN v_inmueble_id;
END; $$ LANGUAGE plpgsql IMMUTABLE;

-- 3) Exclusión: solo 1 actividad activa (oferta o contrato) por inmueble
CREATE OR REPLACE FUNCTION proparcon.trg_check_exclusion_alquiler()
RETURNS trigger AS $$
DECLARE v_inmueble bigint; v_activas int;
BEGIN
  IF TG_OP IN ('INSERT','UPDATE') THEN
    v_inmueble := proparcon.fn_inmueble_de_estancia(NEW.estancia_id);

    SELECT
      (SELECT COUNT(*) FROM proparcon.alquiler_oferta ao
         JOIN proparcon.estancia e1 ON e1.id = ao.estancia_id
       WHERE ao.fecha_baja IS NULL
         AND e1.inmueble_id = v_inmueble
         AND (TG_TABLE_NAME <> 'alquiler_oferta' OR ao.id <> COALESCE(NEW.id,0)))
      +
      (SELECT COUNT(*) FROM proparcon.alquiler_contrato ac
         JOIN proparcon.estancia e2 ON e2.id = ac.estancia_id
       WHERE ac.activo = true
         AND e2.inmueble_id = v_inmueble
         AND (TG_TABLE_NAME <> 'alquiler_contrato' OR ac.id <> COALESCE(NEW.id,0)))
    INTO v_activas;

    IF v_activas > 0 THEN
      RAISE EXCEPTION 'Ya hay alquiler (oferta/contrato) activo en inmueble %', v_inmueble;
    END IF;
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_exclusion_alquiler_oferta   ON proparcon.alquiler_oferta;
CREATE TRIGGER trg_exclusion_alquiler_oferta
BEFORE INSERT OR UPDATE ON proparcon.alquiler_oferta
FOR EACH ROW EXECUTE FUNCTION proparcon.trg_check_exclusion_alquiler();

DROP TRIGGER IF EXISTS trg_exclusion_alquiler_contrato ON proparcon.alquiler_contrato;
CREATE TRIGGER trg_exclusion_alquiler_contrato
BEFORE INSERT OR UPDATE ON proparcon.alquiler_contrato
FOR EACH ROW EXECUTE FUNCTION proparcon.trg_check_exclusion_alquiler();

-- 4) Contrato con ≥ 1 inquilino (deferrable)
CREATE OR REPLACE FUNCTION proparcon.trg_assert_contrato_tiene_inquilino()
RETURNS trigger AS $$
DECLARE v_count int;
BEGIN
  SELECT COUNT(*) INTO v_count FROM proparcon.alquiler_contrato_inquilino i WHERE i.contrato_id = NEW.id;
  IF v_count < 1 THEN
    RAISE EXCEPTION 'Contrato % debe tener ≥1 inquilino', NEW.id;
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS ctr_contrato_tiene_inquilino ON proparcon.alquiler_contrato;
CREATE CONSTRAINT TRIGGER ctr_contrato_tiene_inquilino
AFTER INSERT OR UPDATE ON proparcon.alquiler_contrato
DEFERRABLE INITIALLY DEFERRED
FOR EACH ROW EXECUTE FUNCTION proparcon.trg_assert_contrato_tiene_inquilino();


--- ARCHIVO: sql\05_seeds.sql ---
-- País / Provincia
INSERT INTO proparcon.cat_pais (iso2, nombre) VALUES ('ES','España') ON CONFLICT (iso2) DO NOTHING;

INSERT INTO proparcon.cat_provincia (pais_id, nombre)
SELECT id, 'Madrid' FROM proparcon.cat_pais WHERE iso2='ES'
ON CONFLICT DO NOTHING;

-- Tipos de vía
INSERT INTO proparcon.cat_tipo_via (codigo, descripcion) VALUES
 ('CL','Calle'), ('AV','Avenida'), ('PS','Paseo'), ('TR','Travesía')
ON CONFLICT (codigo) DO NOTHING;

-- Roles
INSERT INTO proparcon.cat_rol (codigo, descripcion) VALUES
 ('GESTOR','Gestor'), ('ENCARGADO','Encargado'), ('PREINQUILINO','PreInquilino'),
 ('INQUILINO','Inquilino'), ('OCUPANTE','Ocupante'), ('PROPIETARIO','Propietario'),
 ('GESTORIA','Gestoría'), ('FIADOR','Fiador'), ('EMPLEADO','Empleado')
ON CONFLICT (codigo) DO NOTHING;

-- Tipos de inmueble
INSERT INTO proparcon.cat_tipo_inmueble (codigo, descripcion) VALUES
 ('PISO','Piso'), ('CHALET','Chalet'), ('LOCAL','Local'),
 ('NAVE','Nave'), ('GARAJE','Plaza de garaje'), ('TRASTERO','Trastero'),
 ('RUSTICA','Rústica'), ('SOLAR','Solar'), ('URBANO','Urbano')
ON CONFLICT (codigo) DO NOTHING;

-- Tipos de estancia
INSERT INTO proparcon.cat_tipo_estancia (codigo, descripcion, alquilable, es_raiz) VALUES
 ('INMUEBLE','Inmueble completo', true, true),
 ('DEPENDENCIA','Dependencia alquilable', true, false),
 ('COCINA','Cocina (no alquilable)', false, false),
 ('BANIO','Baño (no alquilable)', false, false),
 ('SALON','Salón (no alquilable)', false, false),
 ('ASEO','Aseo (no alquilable)', false, false),
 ('TERRAZA','Terraza (no alquilable)', false, false),
 ('BALCON','Balcón (no alquilable)', false, false),
 ('SOLARIUM','Solarium (no alquilable)', false, false)
ON CONFLICT (codigo) DO NOTHING;

-- Derechos de propiedad
INSERT INTO proparcon.cat_tipo_derecho_propiedad (codigo, descripcion) VALUES
 ('USUFRUCTO','Usufructo'), ('NUDA','Nuda propiedad'), ('PLENO','Pleno dominio')
ON CONFLICT (codigo) DO NOTHING;

-- Estados de oferta
INSERT INTO proparcon.cat_estado_oferta_alquiler (codigo, descripcion) VALUES
 ('VACIO','Disponible'), ('RESERVADO','Reservado'), ('EN_OBRA','En obra')
ON CONFLICT (codigo) DO NOTHING;

-- Tipos de aval
INSERT INTO proparcon.cat_tipo_avaliador (codigo, descripcion) VALUES
 ('PERSONA','Aval personal (fiador)'),
 ('SEGURO_IMPAGO','Seguro de impago'),
 ('AVAL_BANCARIO','Aval bancario')
ON CONFLICT (codigo) DO NOTHING;

-- Tipos de ingreso
INSERT INTO proparcon.cat_tipo_ingreso (codigo, descripcion) VALUES
 ('NOMINA','Nómina'), ('NOMINA_B','Nómina en B'), ('PENSION','Pensión'),
 ('AUTONOMO','Autónomo'), ('ESTUDIANTE','Ayuda familiar'),
 ('BECARIO','Beca / ayuda estatal'), ('AHORROS','Ahorros')
ON CONFLICT (codigo) DO NOTHING;

-- Órganos de administración
INSERT INTO proparcon.org_admin_tipo (codigo, descripcion) VALUES
 ('ADM_UNICO','Administrador único'),
 ('SOLIDARIOS','Administradores solidarios'),
 ('MANCOMUNADOS','Administradores mancomunados'),
 ('CONSEJO','Consejo de administración')
ON CONFLICT (codigo) DO NOTHING;


--- ARCHIVO: sql\06_Demo_FINAL.sql ---
-- ============================================================
-- PROPARCON · 06_Demo_FINAL.sql
-- Crea/actualiza el procedimiento sp_demo_final(...)
-- Objetivo:
--   - Cargar/recargar la demo base (inmueble → estancia → oferta → contrato)
--   - Idempotente (no duplica si existe solape)
--   - Contrato se inserta INACTIVO, se asocia un inquilino y se activa
-- Uso típico:
--   CALL proparcon.sp_demo_final();  -- usa parámetros por defecto
--   CALL proparcon.sp_demo_final('2025-11-01', NULL, 850, '2025-12-01', NULL, 900);
-- Requisitos:
--   - Esquema proparcon con tablas: inmueble, estancia, alquiler_oferta, alquiler_contrato
--   - (Opcional) Tablas puente: alquiler_contrato_inquilino o alquiler_contrato_persona
--   - Triggers de exclusión/validación compatibles con que primero se asocia inquilino y luego se activa el contrato
-- Compatibilidad: PostgreSQL 14+
-- ============================================================

SET search_path TO proparcon, public;

CREATE OR REPLACE PROCEDURE proparcon.sp_demo_final(
  IN p_oferta_inicio   date    DEFAULT DATE '2025-11-01',  -- inicio OFERTA demo
  IN p_oferta_fin      date    DEFAULT NULL,               -- fin OFERTA demo (NULL = abierta)
  IN p_oferta_renta    numeric DEFAULT 850,                 -- renta mensual oferta
  IN p_contrato_inicio date    DEFAULT DATE '2025-12-01',   -- inicio CONTRATO demo
  IN p_contrato_fin    date    DEFAULT NULL,                -- fin CONTRATO demo (NULL = abierto)
  IN p_contrato_renta  numeric DEFAULT 900                  -- renta mensual contrato
)
LANGUAGE plpgsql
AS $$
DECLARE
  -- Objetos principales de la demo
  v_estancia    bigint;   -- estancia objetivo (id=6 si existe; si no, la primera)
  v_inmueble    bigint;   -- inmueble asociado a la estancia objetivo
  v_contrato    bigint;   -- contrato demo insertado/seleccionado
  v_persona     bigint;   -- persona demo a asociar como inquilino

  -- Mecanismos de asociación de inquilino
  v_col_inq     text;     -- columna directa (si existe)
  v_tbl_p1      regclass := to_regclass('proparcon.alquiler_contrato_inquilino');   -- (contrato_id, persona_id)
  v_tbl_p2      regclass := to_regclass('proparcon.alquiler_contrato_persona');     -- (contrato_id, persona_id, rol)

  -- Auxiliares
  v_count_est   int;
BEGIN
  -- ============================================================
  -- 1) Saneamiento de rangos incoherentes (no romper CHECKs)
  --    - Alinea fecha_baja < fecha_alta → fecha_baja = fecha_alta
  --    - Alinea fecha_fin < fecha_inicio → fecha_fin = fecha_inicio y activo = FALSE
  -- ============================================================
  UPDATE proparcon.alquiler_oferta
     SET fecha_baja = fecha_alta
   WHERE fecha_baja IS NOT NULL AND fecha_baja < fecha_alta;

  UPDATE proparcon.alquiler_contrato
     SET fecha_fin = fecha_inicio, activo = FALSE
   WHERE fecha_fin IS NOT NULL AND fecha_fin < fecha_inicio;

  -- ============================================================
  -- 2) Garantizar inmueble + estancia
  --    - Si no hay estancias, intenta crear inmueble por defecto y una estancia.
  --    - Si tu tabla inmueble tiene NOT NULLs obligatorios, lanza error claro.
  -- ============================================================
  SELECT COUNT(*) INTO v_count_est FROM proparcon.estancia;
  IF v_count_est = 0 THEN
    BEGIN
      INSERT INTO proparcon.inmueble DEFAULT VALUES RETURNING id INTO v_inmueble;
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear un inmueble con DEFAULT VALUES (NOT NULL requerido). Crea manualmente un inmueble con sus campos obligatorios y vuelve a ejecutar.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando inmueble por defecto (%). Crea uno manualmente y reintenta.', SQLERRM;
    END;

    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id) VALUES (v_inmueble);
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear estancia por defecto (NOT NULL en estancia). Indica columnas requeridas.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando estancia por defecto (%).', SQLERRM;
    END;
  END IF;

  -- ============================================================
  -- 3) Estancia objetivo: id=6 si existe; si no, la primera
  -- ============================================================
  SELECT COALESCE((SELECT 6 WHERE EXISTS (SELECT 1 FROM proparcon.estancia WHERE id=6)),
                  (SELECT MIN(id) FROM proparcon.estancia))
  INTO v_estancia;

  -- Inmueble de la estancia objetivo
  SELECT inmueble_id INTO v_inmueble
  FROM proparcon.estancia
  WHERE id = v_estancia;

  -- ============================================================
  -- 4) Cerrar activos HOY a nivel de inmueble (seguro para CHECKs)
  --    - Ofertas: fecha_baja = COALESCE(fecha_baja, ayer) si siguen activas hoy
  --    - Contratos: fecha_fin = COALESCE(fecha_fin, ayer), activo = FALSE si siguen activos hoy
  -- ============================================================
  UPDATE proparcon.alquiler_oferta o
     SET fecha_baja = COALESCE(o.fecha_baja, CURRENT_DATE - 1)
   WHERE o.estancia_id IN (SELECT id FROM proparcon.estancia WHERE inmueble_id = v_inmueble)
     AND COALESCE(o.fecha_baja, DATE '9999-12-31') >= CURRENT_DATE;

  UPDATE proparcon.alquiler_contrato c
     SET fecha_fin = COALESCE(c.fecha_fin, CURRENT_DATE - 1),
         activo    = FALSE
   WHERE c.estancia_id IN (SELECT id FROM proparcon.estancia WHERE inmueble_id = v_inmueble)
     AND COALESCE(c.fecha_fin, DATE '9999-12-31') >= CURRENT_DATE;

  -- ============================================================
  -- 5) Insertar OFERTA demo (idempotente por solape de rangos)
  -- ============================================================
  INSERT INTO proparcon.alquiler_oferta (estancia_id, fecha_alta, fecha_baja, renta_mensual)
  SELECT v_estancia, p_oferta_inicio, p_oferta_fin, p_oferta_renta
  WHERE NOT EXISTS (
    SELECT 1
    FROM proparcon.alquiler_oferta o
    WHERE o.estancia_id = v_estancia
      AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]')
          && daterange(p_oferta_inicio, COALESCE(p_oferta_fin, DATE '9999-12-31'), '[]')
  );

  -- ============================================================
  -- 6) Insertar CONTRATO demo (idempotente) como INACTIVO
  --    - Luego se asocia inquilino y se activa
  -- ============================================================
  INSERT INTO proparcon.alquiler_contrato (estancia_id, fecha_inicio, fecha_fin, renta_mensual, activo)
  SELECT v_estancia, p_contrato_inicio, p_contrato_fin, p_contrato_renta, FALSE
  WHERE NOT EXISTS (
    SELECT 1
    FROM proparcon.alquiler_contrato c
    WHERE c.estancia_id = v_estancia
      AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]')
          && daterange(p_contrato_inicio, COALESCE(p_contrato_fin, DATE '9999-12-31'), '[]')
  );

  -- Localizar el contrato de demo
  SELECT id INTO v_contrato
  FROM proparcon.alquiler_contrato
  WHERE estancia_id = v_estancia
    AND fecha_inicio = p_contrato_inicio
  ORDER BY id DESC
  LIMIT 1;

  IF v_contrato IS NULL THEN
    RAISE EXCEPTION 'sp_demo_final: no se encontró el contrato de demo (estancia %, inicio %).', v_estancia, p_contrato_inicio;
  END IF;

  -- ============================================================
  -- 7) Persona demo (o la primera existente)
  --    - Si tu tabla persona tiene NOT NULLs, puedes adaptar aquí valores por defecto
  -- ============================================================
  SELECT id INTO v_persona
  FROM proparcon.persona
  ORDER BY id
  LIMIT 1;

  IF v_persona IS NULL THEN
    BEGIN
      INSERT INTO proparcon.persona DEFAULT VALUES RETURNING id INTO v_persona;
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear persona demo con DEFAULT VALUES (NOT NULL). Indica columnas requeridas y reintenta.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando persona demo (%).', SQLERRM;
    END;
  END IF;

  -- ============================================================
  -- 8) Asociar INQUILINO al contrato
  --    - Prioridad: tabla puente v1 → tabla puente v2 → columna directa
  -- ============================================================
  SELECT CASE
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon'
                          AND table_name='alquiler_contrato'
                          AND column_name='inquilino_persona_id')    THEN 'inquilino_persona_id'
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon'
                          AND table_name='alquiler_contrato'
                          AND column_name='arrendatario_persona_id') THEN 'arrendatario_persona_id'
           ELSE NULL
         END
  INTO v_col_inq;

  IF v_tbl_p1 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_inquilino (contrato_id, persona_id)
    SELECT v_contrato, v_persona
    WHERE NOT EXISTS (
      SELECT 1
      FROM proparcon.alquiler_contrato_inquilino
      WHERE contrato_id = v_contrato
        AND persona_id  = v_persona
    );

  ELSIF v_tbl_p2 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_persona (contrato_id, persona_id, rol)
    SELECT v_contrato, v_persona, 'inquilino'
    WHERE NOT EXISTS (
      SELECT 1
      FROM proparcon.alquiler_contrato_persona
      WHERE contrato_id = v_contrato
        AND persona_id  = v_persona
        AND (rol = 'inquilino' OR rol IS NULL)
    );

  ELSIF v_col_inq IS NOT NULL THEN
    EXECUTE format('UPDATE proparcon.alquiler_contrato SET %I = $1 WHERE id = $2', v_col_inq)
    USING v_persona, v_contrato;

  ELSE
    -- Si no hay forma de asociar inquilino, no activamos para no violar triggers
    RAISE NOTICE 'sp_demo_final: no hay tabla puente ni columna directa para inquilinos; el contrato quedará INACTIVO.';
    RETURN;
  END IF;

  -- ============================================================
  -- 9) Activar contrato (ya con ≥1 inquilino asociado)
  -- ============================================================
  UPDATE proparcon.alquiler_contrato
     SET activo = TRUE
   WHERE id = v_contrato;

  RAISE NOTICE 'DEMO FINAL OK · Estancia % · Contrato % · Inquilino %',
               v_estancia, v_contrato, v_persona;
END;
$$;


--- ARCHIVO: sql\06_Demo_MORE_DATA.sql ---
-- ============================================================
-- PROPARCON · 06_Demo_MORE_DATA.sql (versión a prueba de exclusión)
-- Procedimiento: proparcon.sp_demo_more_data()
-- ------------------------------------------------------------
-- Objetivo
--   Generar escenarios extra de demo sin violar el trigger de exclusión
--   a nivel de INMUEBLE:
--     A) Inmueble libre → OFERTA futura (2026-01-10)
--     B) Inmueble libre → CONTRATO futuro (2026-02-01, activo con inquilino)
-- Diseño
--   - No crea inmuebles (evita NOT NULL en tipo_inmueble_id).
--   - Crea estancias (o reutiliza una si hay NOT NULL adicionales).
--   - Idempotente y con guardas a NIVEL INMUEBLE + manejo de excepciones.
--   - Si no hay inmueble libre para una fecha, omite el escenario con NOTICE.
-- Uso
--   CALL proparcon.sp_demo_more_data();
-- ============================================================

SET search_path TO proparcon, public;

CREATE OR REPLACE PROCEDURE proparcon.sp_demo_more_data()
LANGUAGE plpgsql
AS $$
DECLARE
  -- Fechas objetivo
  v_oferta_fecha date := DATE '2026-01-10';
  v_ctr_inicio   date := DATE '2026-02-01';

  -- Inmuebles candidatos (libres)
  v_inmA bigint;  -- para oferta
  v_inmB bigint;  -- para contrato

  -- Estancias objetivo (nuevas o fallback a existentes)
  v_estA bigint;
  v_estB bigint;

  -- Persona demo
  v_pers bigint;

  -- Contrato B
  v_contratoB bigint;

  -- Asociación
  v_tbl_p1 regclass := to_regclass('proparcon.alquiler_contrato_inquilino');
  v_tbl_p2 regclass := to_regclass('proparcon.alquiler_contrato_persona');
  v_col_inq text;

  v_has_final boolean := (to_regprocedure('proparcon.sp_demo_final()') IS NOT NULL);
BEGIN
  -- 0) Asegurar base mínima (si no hay inmuebles)
  IF NOT EXISTS (SELECT 1 FROM proparcon.inmueble) THEN
    IF v_has_final THEN
      CALL proparcon.sp_demo_final();
    END IF;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM proparcon.inmueble) THEN
    RAISE NOTICE 'MORE_DATA: no hay inmuebles; se omiten escenarios.';
    RETURN;
  END IF;

  -- 1) Buscar inmueble libre para v_oferta_fecha
  WITH inm_libres AS (
    SELECT i.id
    FROM proparcon.inmueble i
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_oferta o ON o.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]') @> v_oferta_fecha
    )
    AND NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_contrato c ON c.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]') @> v_oferta_fecha
    )
    ORDER BY i.id
  )
  SELECT id INTO v_inmA FROM inm_libres LIMIT 1;

  IF v_inmA IS NULL THEN
    RAISE NOTICE 'MORE_DATA: sin inmueble libre para OFERTA en %; omito escenario A.', v_oferta_fecha;
  END IF;

  -- 2) Buscar inmueble libre para v_ctr_inicio (distinto de A si hay)
  WITH inm_libres AS (
    SELECT i.id
    FROM proparcon.inmueble i
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_oferta o ON o.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]') @> v_ctr_inicio
    )
    AND NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_contrato c ON c.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]') @> v_ctr_inicio
    )
    ORDER BY i.id
  )
  SELECT id INTO v_inmB FROM inm_libres
  WHERE (v_inmA IS NULL OR id <> v_inmA)
  LIMIT 1;

  IF v_inmB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: sin inmueble libre para CONTRATO en %; omito escenario B.', v_ctr_inicio;
  END IF;

  IF v_inmA IS NULL AND v_inmB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: no hay hueco libre en inmuebles; no se inserta nada.';
    RETURN;
  END IF;

  -- 3) Estancia A (crear o fallback)
  IF v_inmA IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id)
      VALUES (v_inmA)
      RETURNING id INTO v_estA;
    EXCEPTION WHEN not_null_violation THEN
      SELECT id INTO v_estA
      FROM proparcon.estancia
      WHERE inmueble_id = v_inmA
      ORDER BY id
      LIMIT 1;
      IF v_estA IS NULL THEN
        RAISE NOTICE 'MORE_DATA: sin estancia utilizable en inmueble % (A); omito escenario A.', v_inmA;
      END IF;
    END;
  END IF;

  -- 4) Estancia B (crear o fallback)
  IF v_inmB IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id)
      VALUES (v_inmB)
      RETURNING id INTO v_estB;
    EXCEPTION WHEN not_null_violation THEN
      SELECT id INTO v_estB
      FROM proparcon.estancia
      WHERE inmueble_id = v_inmB
      ORDER BY id
      LIMIT 1;
      IF v_estB IS NULL THEN
        RAISE NOTICE 'MORE_DATA: sin estancia utilizable en inmueble % (B); omito escenario B.', v_inmB;
      END IF;
    END;
  END IF;

  IF v_estA IS NULL AND v_estB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: no hay estancias objetivo; no se inserta nada.';
    RETURN;
  END IF;

  -- 5) Escenario A: OFERTA (con guarda a nivel INMUEBLE + try/catch)
  IF v_estA IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.alquiler_oferta (estancia_id, fecha_alta, fecha_baja, renta_mensual)
      SELECT v_estA, v_oferta_fecha, NULL, 700
      WHERE NOT EXISTS (  -- idempotencia por estancia+fecha exacta
        SELECT 1 FROM proparcon.alquiler_oferta
        WHERE estancia_id = v_estA
          AND fecha_alta   = v_oferta_fecha
      )
      AND NOT EXISTS (   -- GUARDA: inmueble libre para esa fecha (ofertas y contratos)
        SELECT 1
        FROM proparcon.estancia e2
        JOIN proparcon.alquiler_oferta o2 ON o2.estancia_id = e2.id
        WHERE e2.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estA)
          AND daterange(o2.fecha_alta, COALESCE(o2.fecha_baja, DATE '9999-12-31'), '[]') @> v_oferta_fecha
      )
      AND NOT EXISTS (
        SELECT 1
        FROM proparcon.estancia e3
        JOIN proparcon.alquiler_contrato c2 ON c2.estancia_id = e3.id
        WHERE e3.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estA)
          AND daterange(c2.fecha_inicio, COALESCE(c2.fecha_fin, DATE '9999-12-31'), '[]') @> v_oferta_fecha
      );
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'MORE_DATA(A): se omitió la oferta por exclusión/trigger: %', SQLERRM;
    END;
  END IF;

  -- 6) Escenario B: CONTRATO (idempotente, inactivo; guarda + try/catch)
  IF v_estB IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.alquiler_contrato (estancia_id, fecha_inicio, fecha_fin, renta_mensual, activo)
      SELECT v_estB, v_ctr_inicio, NULL, 950, FALSE
      WHERE NOT EXISTS (  -- idempotencia por estancia+fecha exacta
        SELECT 1 FROM proparcon.alquiler_contrato
        WHERE estancia_id = v_estB
          AND fecha_inicio = v_ctr_inicio
      )
      AND NOT EXISTS (   -- GUARDA: inmueble libre para esa fecha (ofertas y contratos)
        SELECT 1
        FROM proparcon.estancia e2
        JOIN proparcon.alquiler_oferta o2 ON o2.estancia_id = e2.id
        WHERE e2.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estB)
          AND daterange(o2.fecha_alta, COALESCE(o2.fecha_baja, DATE '9999-12-31'), '[]') @> v_ctr_inicio
      )
      AND NOT EXISTS (
        SELECT 1
        FROM proparcon.estancia e3
        JOIN proparcon.alquiler_contrato c2 ON c2.estancia_id = e3.id
        WHERE e3.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estB)
          AND daterange(c2.fecha_inicio, COALESCE(c2.fecha_fin, DATE '9999-12-31'), '[]') @> v_ctr_inicio
      );
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'MORE_DATA(B): se omitió el contrato por exclusión/trigger: %', SQLERRM;
    END;
  END IF;

  -- 7) Si no se generó contrato B, terminar (escenario A pudo quedar OK)
  SELECT id INTO v_contratoB
  FROM proparcon.alquiler_contrato
  WHERE estancia_id = v_estB
    AND fecha_inicio = v_ctr_inicio
  ORDER BY id DESC
  LIMIT 1;

  IF v_contratoB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: escenario A=% (estancia=%). Escenario B omitido.',
                 (v_estA IS NOT NULL), v_estA;
    RETURN;
  END IF;

  -- 8) Persona demo (o la primera)
  SELECT id INTO v_pers FROM proparcon.persona ORDER BY id LIMIT 1;
  IF v_pers IS NULL THEN
    INSERT INTO proparcon.persona DEFAULT VALUES RETURNING id INTO v_pers;
  END IF;

  -- 9) Asociar inquilino (puente1 → puente2 → columna directa)
  SELECT CASE
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon' AND table_name='alquiler_contrato'
                          AND column_name='inquilino_persona_id')    THEN 'inquilino_persona_id'
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon' AND table_name='alquiler_contrato'
                          AND column_name='arrendatario_persona_id') THEN 'arrendatario_persona_id'
           ELSE NULL
         END INTO v_col_inq;

  IF v_tbl_p1 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_inquilino (contrato_id, persona_id)
    SELECT v_contratoB, v_pers
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.alquiler_contrato_inquilino
      WHERE contrato_id = v_contratoB AND persona_id = v_pers
    );
  ELSIF v_tbl_p2 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_persona (contrato_id, persona_id, rol)
    SELECT v_contratoB, v_pers, 'inquilino'
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.alquiler_contrato_persona
      WHERE contrato_id = v_contratoB
        AND persona_id  = v_pers
        AND (rol = 'inquilino' OR rol IS NULL)
    );
  ELSIF v_col_inq IS NOT NULL THEN
    EXECUTE format('UPDATE proparcon.alquiler_contrato SET %I=$1 WHERE id=$2', v_col_inq)
    USING v_pers, v_contratoB;
  ELSE
    RAISE NOTICE 'MORE_DATA: sin mecanismo de asociación de inquilino; contrato permanece INACTIVO.';
    RETURN;
  END IF;

  -- 10) Activar contrato B
  UPDATE proparcon.alquiler_contrato SET activo = TRUE WHERE id = v_contratoB;

  -- 11) Log final
  RAISE NOTICE 'MORE_DATA OK · InmuebleA=%(EstanciaA=%) · InmuebleB=%(EstanciaB=%, ContratoB=%)',
               v_inmA, v_estA, v_inmB, v_estB, v_contratoB;
END;
$$;


--- ARCHIVO: sql\Proparcon_Cat_dll.sql ---
-- proparcon.cat_estado_contrato definition

-- Drop table

-- DROP TABLE proparcon.cat_estado_contrato;

CREATE TABLE proparcon.cat_estado_contrato (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_estado_contrato_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_estado_contrato_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_estado_contrato OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_estado_contrato TO "admin";


-- proparcon.cat_estado_oferta_alquiler definition

-- Drop table

-- DROP TABLE proparcon.cat_estado_oferta_alquiler;

CREATE TABLE proparcon.cat_estado_oferta_alquiler (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_estado_oferta_alquiler_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_estado_oferta_alquiler_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_estado_oferta_alquiler OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_estado_oferta_alquiler TO "admin";


-- proparcon.cat_pais definition

-- Drop table

-- DROP TABLE proparcon.cat_pais;

CREATE TABLE proparcon.cat_pais (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	iso2 bpchar(2) NOT NULL,
	nombre text NOT NULL,
	CONSTRAINT cat_pais_iso2_key UNIQUE (iso2),
	CONSTRAINT cat_pais_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_pais OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_pais TO "admin";


-- proparcon.cat_rol definition

-- Drop table

-- DROP TABLE proparcon.cat_rol;

CREATE TABLE proparcon.cat_rol (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_rol_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_rol_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_rol OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_rol TO "admin";


-- proparcon.cat_tipo_avaliador definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_avaliador;

CREATE TABLE proparcon.cat_tipo_avaliador (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_avaliador_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_avaliador_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_avaliador OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_avaliador TO "admin";


-- proparcon.cat_tipo_contrato definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_contrato;

CREATE TABLE proparcon.cat_tipo_contrato (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_contrato_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_contrato_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_contrato OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_contrato TO "admin";


-- proparcon.cat_tipo_derecho_propiedad definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_derecho_propiedad;

CREATE TABLE proparcon.cat_tipo_derecho_propiedad (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_derecho_propiedad_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_derecho_propiedad_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_derecho_propiedad OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_derecho_propiedad TO "admin";


-- proparcon.cat_tipo_estancia definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_estancia;

CREATE TABLE proparcon.cat_tipo_estancia (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	alquilable bool DEFAULT false NOT NULL,
	es_raiz bool DEFAULT false NOT NULL,
	CONSTRAINT cat_tipo_estancia_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_estancia_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_estancia OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_estancia TO "admin";


-- proparcon.cat_tipo_ingreso definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_ingreso;

CREATE TABLE proparcon.cat_tipo_ingreso (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_ingreso_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_ingreso_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_ingreso OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_ingreso TO "admin";


-- proparcon.cat_tipo_inmueble definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_inmueble;

CREATE TABLE proparcon.cat_tipo_inmueble (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(40) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_inmueble_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_inmueble_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_inmueble OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_inmueble TO "admin";


-- proparcon.cat_tipo_via definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_via;

CREATE TABLE proparcon.cat_tipo_via (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	codigo varchar(20) NOT NULL,
	descripcion text NOT NULL,
	CONSTRAINT cat_tipo_via_codigo_key UNIQUE (codigo),
	CONSTRAINT cat_tipo_via_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE proparcon.cat_tipo_via OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_via TO "admin";


-- proparcon.cat_provincia definition

-- Drop table

-- DROP TABLE proparcon.cat_provincia;

CREATE TABLE proparcon.cat_provincia (
	id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	pais_id int4 NOT NULL,
	nombre text NOT NULL,
	CONSTRAINT cat_provincia_pais_id_nombre_key UNIQUE (pais_id, nombre),
	CONSTRAINT cat_provincia_pkey PRIMARY KEY (id),
	CONSTRAINT cat_provincia_pais_id_fkey FOREIGN KEY (pais_id) REFERENCES proparcon.cat_pais(id)
);

-- Permissions

ALTER TABLE proparcon.cat_provincia OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_provincia TO "admin";

--- ARCHIVO: sql\Proparcon_ddl.sql ---
-- DROP SCHEMA proparcon;

CREATE SCHEMA proparcon AUTHORIZATION "admin";

-- DROP SEQUENCE proparcon.alquiler_contrato_aval_id_seq;

CREATE SEQUENCE proparcon.alquiler_contrato_aval_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.alquiler_contrato_aval_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.alquiler_contrato_aval_id_seq TO "admin";

-- DROP SEQUENCE proparcon.alquiler_contrato_id_seq;

CREATE SEQUENCE proparcon.alquiler_contrato_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.alquiler_contrato_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.alquiler_contrato_id_seq TO "admin";

-- DROP SEQUENCE proparcon.alquiler_contrato_inquilino_id_seq;

CREATE SEQUENCE proparcon.alquiler_contrato_inquilino_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.alquiler_contrato_inquilino_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.alquiler_contrato_inquilino_id_seq TO "admin";

-- DROP SEQUENCE proparcon.alquiler_oferta_id_seq;

CREATE SEQUENCE proparcon.alquiler_oferta_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.alquiler_oferta_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.alquiler_oferta_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_estado_contrato_id_seq;

CREATE SEQUENCE proparcon.cat_estado_contrato_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_estado_contrato_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_estado_contrato_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_estado_oferta_alquiler_id_seq;

CREATE SEQUENCE proparcon.cat_estado_oferta_alquiler_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_estado_oferta_alquiler_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_estado_oferta_alquiler_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_pais_id_seq;

CREATE SEQUENCE proparcon.cat_pais_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_pais_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_pais_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_provincia_id_seq;

CREATE SEQUENCE proparcon.cat_provincia_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_provincia_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_provincia_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_rol_id_seq;

CREATE SEQUENCE proparcon.cat_rol_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_rol_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_rol_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_avaliador_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_avaliador_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_avaliador_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_avaliador_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_contrato_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_contrato_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_contrato_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_contrato_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_derecho_propiedad_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_derecho_propiedad_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_derecho_propiedad_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_derecho_propiedad_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_estancia_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_estancia_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_estancia_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_estancia_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_ingreso_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_ingreso_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_ingreso_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_ingreso_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_inmueble_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_inmueble_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_inmueble_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_inmueble_id_seq TO "admin";

-- DROP SEQUENCE proparcon.cat_tipo_via_id_seq;

CREATE SEQUENCE proparcon.cat_tipo_via_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.cat_tipo_via_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.cat_tipo_via_id_seq TO "admin";

-- DROP SEQUENCE proparcon.catastro_id_seq;

CREATE SEQUENCE proparcon.catastro_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.catastro_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.catastro_id_seq TO "admin";

-- DROP SEQUENCE proparcon.centro_trabajo_id_seq;

CREATE SEQUENCE proparcon.centro_trabajo_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.centro_trabajo_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.centro_trabajo_id_seq TO "admin";

-- DROP SEQUENCE proparcon.direccion_id_seq;

CREATE SEQUENCE proparcon.direccion_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.direccion_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.direccion_id_seq TO "admin";

-- DROP SEQUENCE proparcon.empleado_id_seq;

CREATE SEQUENCE proparcon.empleado_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.empleado_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.empleado_id_seq TO "admin";

-- DROP SEQUENCE proparcon.entidad_bancaria_id_seq;

CREATE SEQUENCE proparcon.entidad_bancaria_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.entidad_bancaria_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.entidad_bancaria_id_seq TO "admin";

-- DROP SEQUENCE proparcon.estancia_id_seq;

CREATE SEQUENCE proparcon.estancia_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.estancia_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.estancia_id_seq TO "admin";

-- DROP SEQUENCE proparcon.inmueble_id_seq;

CREATE SEQUENCE proparcon.inmueble_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.inmueble_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.inmueble_id_seq TO "admin";

-- DROP SEQUENCE proparcon.inmueble_propiedad_id_seq;

CREATE SEQUENCE proparcon.inmueble_propiedad_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.inmueble_propiedad_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.inmueble_propiedad_id_seq TO "admin";

-- DROP SEQUENCE proparcon.juridica_id_seq;

CREATE SEQUENCE proparcon.juridica_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.juridica_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.juridica_id_seq TO "admin";

-- DROP SEQUENCE proparcon.org_admin_id_seq;

CREATE SEQUENCE proparcon.org_admin_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.org_admin_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.org_admin_id_seq TO "admin";

-- DROP SEQUENCE proparcon.org_admin_miembro_id_seq;

CREATE SEQUENCE proparcon.org_admin_miembro_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.org_admin_miembro_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.org_admin_miembro_id_seq TO "admin";

-- DROP SEQUENCE proparcon.org_admin_tipo_id_seq;

CREATE SEQUENCE proparcon.org_admin_tipo_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.org_admin_tipo_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.org_admin_tipo_id_seq TO "admin";

-- DROP SEQUENCE proparcon.persona_id_seq;

CREATE SEQUENCE proparcon.persona_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.persona_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.persona_id_seq TO "admin";

-- DROP SEQUENCE proparcon.persona_rol_id_seq;

CREATE SEQUENCE proparcon.persona_rol_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.persona_rol_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.persona_rol_id_seq TO "admin";

-- DROP SEQUENCE proparcon.registro_propiedad_id_seq;

CREATE SEQUENCE proparcon.registro_propiedad_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.registro_propiedad_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.registro_propiedad_id_seq TO "admin";

-- DROP SEQUENCE proparcon.users_id_seq;

CREATE SEQUENCE proparcon.users_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE proparcon.users_id_seq OWNER TO "admin";
GRANT ALL ON SEQUENCE proparcon.users_id_seq TO "admin";
-- proparcon.alembic_version definition

-- Drop table

-- DROP TABLE proparcon.alembic_version;

CREATE TABLE proparcon.alembic_version ( version_num varchar(32) NOT NULL, CONSTRAINT alembic_version_pkc null);

-- Permissions

ALTER TABLE proparcon.alembic_version OWNER TO "admin";
GRANT ALL ON TABLE proparcon.alembic_version TO "admin";


-- proparcon.cat_estado_contrato definition

-- Drop table

-- DROP TABLE proparcon.cat_estado_contrato;

CREATE TABLE proparcon.cat_estado_contrato ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_estado_contrato_codigo_key UNIQUE (codigo), CONSTRAINT cat_estado_contrato_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_estado_contrato OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_estado_contrato TO "admin";


-- proparcon.cat_estado_oferta_alquiler definition

-- Drop table

-- DROP TABLE proparcon.cat_estado_oferta_alquiler;

CREATE TABLE proparcon.cat_estado_oferta_alquiler ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_estado_oferta_alquiler_codigo_key UNIQUE (codigo), CONSTRAINT cat_estado_oferta_alquiler_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_estado_oferta_alquiler OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_estado_oferta_alquiler TO "admin";


-- proparcon.cat_pais definition

-- Drop table

-- DROP TABLE proparcon.cat_pais;

CREATE TABLE proparcon.cat_pais ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, iso2 bpchar(2) NOT NULL, nombre text NOT NULL, CONSTRAINT cat_pais_iso2_key UNIQUE (iso2), CONSTRAINT cat_pais_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_pais OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_pais TO "admin";


-- proparcon.cat_rol definition

-- Drop table

-- DROP TABLE proparcon.cat_rol;

CREATE TABLE proparcon.cat_rol ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_rol_codigo_key UNIQUE (codigo), CONSTRAINT cat_rol_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_rol OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_rol TO "admin";


-- proparcon.cat_tipo_avaliador definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_avaliador;

CREATE TABLE proparcon.cat_tipo_avaliador ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_avaliador_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_avaliador_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_avaliador OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_avaliador TO "admin";


-- proparcon.cat_tipo_contrato definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_contrato;

CREATE TABLE proparcon.cat_tipo_contrato ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_contrato_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_contrato_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_contrato OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_contrato TO "admin";


-- proparcon.cat_tipo_derecho_propiedad definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_derecho_propiedad;

CREATE TABLE proparcon.cat_tipo_derecho_propiedad ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_derecho_propiedad_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_derecho_propiedad_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_derecho_propiedad OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_derecho_propiedad TO "admin";


-- proparcon.cat_tipo_estancia definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_estancia;

CREATE TABLE proparcon.cat_tipo_estancia ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, alquilable bool DEFAULT false NOT NULL, es_raiz bool DEFAULT false NOT NULL, CONSTRAINT cat_tipo_estancia_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_estancia_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_estancia OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_estancia TO "admin";


-- proparcon.cat_tipo_ingreso definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_ingreso;

CREATE TABLE proparcon.cat_tipo_ingreso ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_ingreso_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_ingreso_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_ingreso OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_ingreso TO "admin";


-- proparcon.cat_tipo_inmueble definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_inmueble;

CREATE TABLE proparcon.cat_tipo_inmueble ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_inmueble_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_inmueble_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_inmueble OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_inmueble TO "admin";


-- proparcon.cat_tipo_via definition

-- Drop table

-- DROP TABLE proparcon.cat_tipo_via;

CREATE TABLE proparcon.cat_tipo_via ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(20) NOT NULL, descripcion text NOT NULL, CONSTRAINT cat_tipo_via_codigo_key UNIQUE (codigo), CONSTRAINT cat_tipo_via_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.cat_tipo_via OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_tipo_via TO "admin";


-- proparcon.entidad_bancaria definition

-- Drop table

-- DROP TABLE proparcon.entidad_bancaria;

CREATE TABLE proparcon.entidad_bancaria ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, nombre text NOT NULL, cod_banco_esp bpchar(4) NULL, swift_bic varchar(11) NULL, CONSTRAINT entidad_bancaria_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.entidad_bancaria OWNER TO "admin";
GRANT ALL ON TABLE proparcon.entidad_bancaria TO "admin";


-- proparcon.org_admin_tipo definition

-- Drop table

-- DROP TABLE proparcon.org_admin_tipo;

CREATE TABLE proparcon.org_admin_tipo ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, codigo varchar(40) NOT NULL, descripcion text NOT NULL, CONSTRAINT org_admin_tipo_codigo_key UNIQUE (codigo), CONSTRAINT org_admin_tipo_pkey PRIMARY KEY (id));

-- Permissions

ALTER TABLE proparcon.org_admin_tipo OWNER TO "admin";
GRANT ALL ON TABLE proparcon.org_admin_tipo TO "admin";


-- proparcon.cat_provincia definition

-- Drop table

-- DROP TABLE proparcon.cat_provincia;

CREATE TABLE proparcon.cat_provincia ( id int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, pais_id int4 NOT NULL, nombre text NOT NULL, CONSTRAINT cat_provincia_pais_id_nombre_key UNIQUE (pais_id, nombre), CONSTRAINT cat_provincia_pkey PRIMARY KEY (id), CONSTRAINT cat_provincia_pais_id_fkey FOREIGN KEY (pais_id) REFERENCES proparcon.cat_pais(id));

-- Permissions

ALTER TABLE proparcon.cat_provincia OWNER TO "admin";
GRANT ALL ON TABLE proparcon.cat_provincia TO "admin";


-- proparcon.direccion definition

-- Drop table

-- DROP TABLE proparcon.direccion;

CREATE TABLE proparcon.direccion ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, tipo_via_id int4 NULL, via_nombre text NOT NULL, numero varchar(10) NULL, escalera varchar(10) NULL, piso varchar(10) NULL, puerta varchar(10) NULL, cp varchar(10) NULL, municipio text NULL, provincia_id int4 NULL, pais_id int4 NULL, observaciones text NULL, CONSTRAINT direccion_pkey PRIMARY KEY (id), CONSTRAINT direccion_pais_id_fkey FOREIGN KEY (pais_id) REFERENCES proparcon.cat_pais(id), CONSTRAINT direccion_provincia_id_fkey FOREIGN KEY (provincia_id) REFERENCES proparcon.cat_provincia(id), CONSTRAINT direccion_tipo_via_id_fkey FOREIGN KEY (tipo_via_id) REFERENCES proparcon.cat_tipo_via(id));

-- Permissions

ALTER TABLE proparcon.direccion OWNER TO "admin";
GRANT ALL ON TABLE proparcon.direccion TO "admin";


-- proparcon.juridica definition

-- Drop table

-- DROP TABLE proparcon.juridica;

CREATE TABLE proparcon.juridica ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, cif varchar(20) NOT NULL, denominacion_social text NOT NULL, abreviatura varchar(10) NULL, domicilio_fiscal_id int8 NULL, acta_titularidad_real date NULL, CONSTRAINT juridica_cif_key UNIQUE (cif), CONSTRAINT juridica_pkey PRIMARY KEY (id), CONSTRAINT juridica_domicilio_fiscal_id_fkey FOREIGN KEY (domicilio_fiscal_id) REFERENCES proparcon.direccion(id));

-- Permissions

ALTER TABLE proparcon.juridica OWNER TO "admin";
GRANT ALL ON TABLE proparcon.juridica TO "admin";


-- proparcon.org_admin definition

-- Drop table

-- DROP TABLE proparcon.org_admin;

CREATE TABLE proparcon.org_admin ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, juridica_id int8 NOT NULL, tipo_id int4 NOT NULL, fecha_escritura date NULL, CONSTRAINT org_admin_pkey PRIMARY KEY (id), CONSTRAINT org_admin_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id) ON DELETE CASCADE, CONSTRAINT org_admin_tipo_id_fkey FOREIGN KEY (tipo_id) REFERENCES proparcon.org_admin_tipo(id));

-- Permissions

ALTER TABLE proparcon.org_admin OWNER TO "admin";
GRANT ALL ON TABLE proparcon.org_admin TO "admin";


-- proparcon.persona definition

-- Drop table

-- DROP TABLE proparcon.persona;

CREATE TABLE proparcon.persona ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, tipo_doc varchar(20) NOT NULL, doc_identidad text NOT NULL, nombre text NOT NULL, apellido1 text NOT NULL, apellido2 text NULL, fecha_nacimiento date NULL, lugar_nacimiento text NULL, nacionalidad text NULL, profesion text NULL, direccion_id int8 NULL, telefono_fijo varchar(25) NULL, telefono_movil varchar(25) NULL, email_particular text NULL, email_laboral text NULL, nick text NULL, linkedin text NULL, iban text NULL, CONSTRAINT persona_doc_identidad_check CHECK (((length(doc_identidad) >= 3) AND (length(doc_identidad) <= 64))), CONSTRAINT persona_pkey PRIMARY KEY (id), CONSTRAINT persona_tipo_doc_doc_identidad_key UNIQUE (tipo_doc, doc_identidad), CONSTRAINT persona_direccion_id_fkey FOREIGN KEY (direccion_id) REFERENCES proparcon.direccion(id));
CREATE INDEX proparcon_idx_persona_doc ON proparcon.persona USING btree (tipo_doc, doc_identidad);

-- Permissions

ALTER TABLE proparcon.persona OWNER TO "admin";
GRANT ALL ON TABLE proparcon.persona TO "admin";


-- proparcon.persona_rol definition

-- Drop table

-- DROP TABLE proparcon.persona_rol;

CREATE TABLE proparcon.persona_rol ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, persona_id int8 NOT NULL, rol_id int4 NOT NULL, gestor_supervisor_id int8 NULL, fecha_alta date DEFAULT now() NULL, fecha_baja date NULL, CONSTRAINT persona_rol_persona_id_rol_id_key UNIQUE (persona_id, rol_id), CONSTRAINT persona_rol_pkey PRIMARY KEY (id), CONSTRAINT persona_rol_gestor_supervisor_id_fkey FOREIGN KEY (gestor_supervisor_id) REFERENCES proparcon.persona(id), CONSTRAINT persona_rol_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id) ON DELETE CASCADE, CONSTRAINT persona_rol_rol_id_fkey FOREIGN KEY (rol_id) REFERENCES proparcon.cat_rol(id));
CREATE INDEX proparcon_idx_persona_rol ON proparcon.persona_rol USING btree (persona_id, rol_id);

-- Permissions

ALTER TABLE proparcon.persona_rol OWNER TO "admin";
GRANT ALL ON TABLE proparcon.persona_rol TO "admin";


-- proparcon.users definition

-- Drop table

-- DROP TABLE proparcon.users;

CREATE TABLE proparcon.users ( id varchar(50) DEFAULT nextval('users_id_seq'::regclass) NOT NULL, persona_id int8 NOT NULL, email varchar(255) NOT NULL, password_hash varchar(255) NOT NULL, is_active bool DEFAULT true NOT NULL, fecha_creacion timestamp DEFAULT now() NULL, "role" varchar(20) DEFAULT 'lector'::character varying NOT NULL, CONSTRAINT users_email_key UNIQUE (email), CONSTRAINT users_persona_id_key UNIQUE (persona_id), CONSTRAINT users_pkey PRIMARY KEY (id), CONSTRAINT users_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id));

-- Permissions

ALTER TABLE proparcon.users OWNER TO "admin";
GRANT ALL ON TABLE proparcon.users TO "admin";


-- proparcon.centro_trabajo definition

-- Drop table

-- DROP TABLE proparcon.centro_trabajo;

CREATE TABLE proparcon.centro_trabajo ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, juridica_id int8 NOT NULL, direccion_id int8 NOT NULL, CONSTRAINT centro_trabajo_pkey PRIMARY KEY (id), CONSTRAINT centro_trabajo_direccion_id_fkey FOREIGN KEY (direccion_id) REFERENCES proparcon.direccion(id), CONSTRAINT centro_trabajo_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id) ON DELETE CASCADE);

-- Permissions

ALTER TABLE proparcon.centro_trabajo OWNER TO "admin";
GRANT ALL ON TABLE proparcon.centro_trabajo TO "admin";


-- proparcon.empleado definition

-- Drop table

-- DROP TABLE proparcon.empleado;

CREATE TABLE proparcon.empleado ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, persona_id int8 NOT NULL, juridica_id int8 NOT NULL, centro_trabajo_id int8 NULL, CONSTRAINT empleado_persona_id_juridica_id_key UNIQUE (persona_id, juridica_id), CONSTRAINT empleado_pkey PRIMARY KEY (id), CONSTRAINT empleado_centro_trabajo_id_fkey FOREIGN KEY (centro_trabajo_id) REFERENCES proparcon.centro_trabajo(id), CONSTRAINT empleado_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id) ON DELETE CASCADE, CONSTRAINT empleado_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id) ON DELETE CASCADE);

-- Permissions

ALTER TABLE proparcon.empleado OWNER TO "admin";
GRANT ALL ON TABLE proparcon.empleado TO "admin";


-- proparcon.inmueble definition

-- Drop table

-- DROP TABLE proparcon.inmueble;

CREATE TABLE proparcon.inmueble ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, tipo_inmueble_id int4 NOT NULL, nombre_publico text NULL, direccion_id int8 NULL, gestor_persona_id int8 NULL, encargado_persona_id int8 NULL, gestoria_juridica_id int8 NULL, CONSTRAINT inmueble_pkey PRIMARY KEY (id), CONSTRAINT inmueble_direccion_id_fkey FOREIGN KEY (direccion_id) REFERENCES proparcon.direccion(id), CONSTRAINT inmueble_encargado_persona_id_fkey FOREIGN KEY (encargado_persona_id) REFERENCES proparcon.persona(id), CONSTRAINT inmueble_gestor_persona_id_fkey FOREIGN KEY (gestor_persona_id) REFERENCES proparcon.persona(id), CONSTRAINT inmueble_gestoria_juridica_id_fkey FOREIGN KEY (gestoria_juridica_id) REFERENCES proparcon.juridica(id), CONSTRAINT inmueble_tipo_inmueble_id_fkey FOREIGN KEY (tipo_inmueble_id) REFERENCES proparcon.cat_tipo_inmueble(id));
CREATE INDEX proparcon_idx_inmueble_gestor ON proparcon.inmueble USING btree (gestor_persona_id);

-- Permissions

ALTER TABLE proparcon.inmueble OWNER TO "admin";
GRANT ALL ON TABLE proparcon.inmueble TO "admin";


-- proparcon.inmueble_propiedad definition

-- Drop table

-- DROP TABLE proparcon.inmueble_propiedad;

CREATE TABLE proparcon.inmueble_propiedad ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, inmueble_id int8 NOT NULL, persona_id int8 NULL, juridica_id int8 NULL, tipo_derecho_id int4 NOT NULL, porcentaje numeric(5, 2) NOT NULL, CONSTRAINT inmueble_propiedad_check CHECK ((((persona_id IS NOT NULL) AND (juridica_id IS NULL)) OR ((persona_id IS NULL) AND (juridica_id IS NOT NULL)))), CONSTRAINT inmueble_propiedad_pkey PRIMARY KEY (id), CONSTRAINT inmueble_propiedad_porcentaje_check CHECK (((porcentaje >= (0)::numeric) AND (porcentaje <= (100)::numeric))), CONSTRAINT inmueble_propiedad_inmueble_id_fkey FOREIGN KEY (inmueble_id) REFERENCES proparcon.inmueble(id) ON DELETE CASCADE, CONSTRAINT inmueble_propiedad_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id), CONSTRAINT inmueble_propiedad_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id), CONSTRAINT inmueble_propiedad_tipo_derecho_id_fkey FOREIGN KEY (tipo_derecho_id) REFERENCES proparcon.cat_tipo_derecho_propiedad(id));
CREATE INDEX proparcon_idx_inm_prop_inmueble ON proparcon.inmueble_propiedad USING btree (inmueble_id);
CREATE INDEX proparcon_idx_inm_prop_tipo ON proparcon.inmueble_propiedad USING btree (tipo_derecho_id);

-- Table Triggers

create trigger trg_propiedades_100 after
insert
    or
delete
    or
update
    on
    proparcon.inmueble_propiedad for each statement execute function trg_check_propiedades_100();

-- Permissions

ALTER TABLE proparcon.inmueble_propiedad OWNER TO "admin";
GRANT ALL ON TABLE proparcon.inmueble_propiedad TO "admin";


-- proparcon.org_admin_miembro definition

-- Drop table

-- DROP TABLE proparcon.org_admin_miembro;

CREATE TABLE proparcon.org_admin_miembro ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, org_admin_id int8 NOT NULL, persona_id int8 NULL, juridica_id int8 NULL, representante_persona_id int8 NULL, CONSTRAINT org_admin_miembro_check CHECK ((((persona_id IS NOT NULL) AND (juridica_id IS NULL)) OR ((persona_id IS NULL) AND (juridica_id IS NOT NULL)))), CONSTRAINT org_admin_miembro_pkey PRIMARY KEY (id), CONSTRAINT org_admin_miembro_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id), CONSTRAINT org_admin_miembro_org_admin_id_fkey FOREIGN KEY (org_admin_id) REFERENCES proparcon.org_admin(id) ON DELETE CASCADE, CONSTRAINT org_admin_miembro_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id), CONSTRAINT org_admin_miembro_representante_persona_id_fkey FOREIGN KEY (representante_persona_id) REFERENCES proparcon.persona(id));

-- Permissions

ALTER TABLE proparcon.org_admin_miembro OWNER TO "admin";
GRANT ALL ON TABLE proparcon.org_admin_miembro TO "admin";


-- proparcon.registro_propiedad definition

-- Drop table

-- DROP TABLE proparcon.registro_propiedad;

CREATE TABLE proparcon.registro_propiedad ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, inmueble_id int8 NOT NULL, localidad text NOT NULL, registro_numero text NOT NULL, seccion text NULL, finca text NOT NULL, cru_idufir text NULL, arp_fecha date NULL, nota_simple_url text NULL, CONSTRAINT registro_propiedad_cru_idufir_key UNIQUE (cru_idufir), CONSTRAINT registro_propiedad_inmueble_id_key UNIQUE (inmueble_id), CONSTRAINT registro_propiedad_pkey PRIMARY KEY (id), CONSTRAINT registro_propiedad_inmueble_id_fkey FOREIGN KEY (inmueble_id) REFERENCES proparcon.inmueble(id) ON DELETE CASCADE);

-- Permissions

ALTER TABLE proparcon.registro_propiedad OWNER TO "admin";
GRANT ALL ON TABLE proparcon.registro_propiedad TO "admin";


-- proparcon.catastro definition

-- Drop table

-- DROP TABLE proparcon.catastro;

CREATE TABLE proparcon.catastro ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, inmueble_id int8 NOT NULL, ref_catastral varchar(20) NOT NULL, direccion_catastral_id int8 NULL, uso text NULL, anio_construccion int4 NULL, coef_participacion numeric(5, 2) NULL, sup_construida numeric(10, 2) NULL, sup_parcela numeric(10, 2) NULL, CONSTRAINT catastro_coef_participacion_check CHECK (((coef_participacion >= (0)::numeric) AND (coef_participacion <= (100)::numeric))), CONSTRAINT catastro_inmueble_id_key UNIQUE (inmueble_id), CONSTRAINT catastro_pkey PRIMARY KEY (id), CONSTRAINT catastro_ref_catastral_key UNIQUE (ref_catastral), CONSTRAINT catastro_direccion_catastral_id_fkey FOREIGN KEY (direccion_catastral_id) REFERENCES proparcon.direccion(id), CONSTRAINT catastro_inmueble_id_fkey FOREIGN KEY (inmueble_id) REFERENCES proparcon.inmueble(id) ON DELETE CASCADE);

-- Permissions

ALTER TABLE proparcon.catastro OWNER TO "admin";
GRANT ALL ON TABLE proparcon.catastro TO "admin";


-- proparcon.estancia definition

-- Drop table

-- DROP TABLE proparcon.estancia;

CREATE TABLE proparcon.estancia ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, inmueble_id int8 NOT NULL, tipo_estancia_id int4 NOT NULL, nombre text NULL, parent_estancia_id int8 NULL, CONSTRAINT estancia_inmueble_id_nombre_key UNIQUE (inmueble_id, nombre), CONSTRAINT estancia_pkey PRIMARY KEY (id), CONSTRAINT estancia_inmueble_id_fkey FOREIGN KEY (inmueble_id) REFERENCES proparcon.inmueble(id) ON DELETE CASCADE, CONSTRAINT estancia_parent_estancia_id_fkey FOREIGN KEY (parent_estancia_id) REFERENCES proparcon.estancia(id), CONSTRAINT estancia_tipo_estancia_id_fkey FOREIGN KEY (tipo_estancia_id) REFERENCES proparcon.cat_tipo_estancia(id));
CREATE INDEX proparcon_idx_estancia_inmueble ON proparcon.estancia USING btree (inmueble_id);

-- Permissions

ALTER TABLE proparcon.estancia OWNER TO "admin";
GRANT ALL ON TABLE proparcon.estancia TO "admin";


-- proparcon.alquiler_oferta definition

-- Drop table

-- DROP TABLE proparcon.alquiler_oferta;

CREATE TABLE proparcon.alquiler_oferta ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, estancia_id int8 NOT NULL, estado_id int4 NOT NULL, renta_mensual numeric(12, 2) NOT NULL, gestor_persona_id int8 NULL, encargado_persona_id int8 NULL, fecha_alta date DEFAULT now() NOT NULL, fecha_baja date NULL, CONSTRAINT alquiler_oferta_pkey PRIMARY KEY (id), CONSTRAINT alquiler_oferta_renta_mensual_check CHECK ((renta_mensual >= (0)::numeric)), CONSTRAINT alquiler_oferta_encargado_persona_id_fkey FOREIGN KEY (encargado_persona_id) REFERENCES proparcon.persona(id), CONSTRAINT alquiler_oferta_estado_id_fkey FOREIGN KEY (estado_id) REFERENCES proparcon.cat_estado_oferta_alquiler(id), CONSTRAINT alquiler_oferta_estancia_id_fkey FOREIGN KEY (estancia_id) REFERENCES proparcon.estancia(id) ON DELETE CASCADE, CONSTRAINT alquiler_oferta_gestor_persona_id_fkey FOREIGN KEY (gestor_persona_id) REFERENCES proparcon.persona(id));
CREATE INDEX proparcon_idx_alq_oferta_estancia ON proparcon.alquiler_oferta USING btree (estancia_id);

-- Permissions

ALTER TABLE proparcon.alquiler_oferta OWNER TO "admin";
GRANT ALL ON TABLE proparcon.alquiler_oferta TO "admin";


-- proparcon.alquiler_contrato definition

-- Drop table

-- DROP TABLE proparcon.alquiler_contrato;

CREATE TABLE proparcon.alquiler_contrato ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, estancia_id int8 NOT NULL, fecha_inicio date NOT NULL, fecha_fin date NULL, contrato_pdf_url text NULL, gestor_persona_id int8 NULL, encargado_persona_id int8 NULL, renta_mensual numeric(12, 2) NOT NULL, estado_id int4 DEFAULT 1 NOT NULL, oferta_id int8 NULL, fianza numeric(12, 2) NULL, tipo_contrato_id int4 NULL, CONSTRAINT alquiler_contrato_fianza_check CHECK ((fianza >= (0)::numeric)), CONSTRAINT alquiler_contrato_pkey PRIMARY KEY (id), CONSTRAINT alquiler_contrato_renta_mensual_check CHECK ((renta_mensual >= (0)::numeric)), CONSTRAINT trg_assert_contrato_tiene_titular TRIGGER DEFERRABLE INITIALLY DEFERRED, CONSTRAINT alquiler_contrato_encargado_persona_id_fkey FOREIGN KEY (encargado_persona_id) REFERENCES proparcon.persona(id), CONSTRAINT alquiler_contrato_estado_id_fkey FOREIGN KEY (estado_id) REFERENCES proparcon.cat_estado_contrato(id), CONSTRAINT alquiler_contrato_estancia_id_fkey FOREIGN KEY (estancia_id) REFERENCES proparcon.estancia(id) ON DELETE CASCADE, CONSTRAINT alquiler_contrato_gestor_persona_id_fkey FOREIGN KEY (gestor_persona_id) REFERENCES proparcon.persona(id), CONSTRAINT alquiler_contrato_oferta_id_fkey FOREIGN KEY (oferta_id) REFERENCES proparcon.alquiler_oferta(id), CONSTRAINT alquiler_contrato_tipo_contrato_id_fkey FOREIGN KEY (tipo_contrato_id) REFERENCES proparcon.cat_tipo_contrato(id));
CREATE INDEX proparcon_idx_alq_contrato_estancia ON proparcon.alquiler_contrato USING btree (estancia_id);

-- Table Triggers

create constraint trigger trg_assert_contrato_tiene_titular after
update
    of estado_id on
    proparcon.alquiler_contrato deferrable initially deferred for each row execute function trg_assert_contrato_tiene_inquilino_titular();
create trigger trg_exclusion_alquiler_contrato_estancia before
insert
    or
update
    of estancia_id,
    estado_id on
    proparcon.alquiler_contrato for each row execute function trg_check_exclusion_alquiler_estancia();

-- Permissions

ALTER TABLE proparcon.alquiler_contrato OWNER TO "admin";
GRANT ALL ON TABLE proparcon.alquiler_contrato TO "admin";


-- proparcon.alquiler_contrato_aval definition

-- Drop table

-- DROP TABLE proparcon.alquiler_contrato_aval;

CREATE TABLE proparcon.alquiler_contrato_aval ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, contrato_id int8 NOT NULL, tipo_avaliador_id int4 NOT NULL, persona_id int8 NULL, juridica_id int8 NULL, entidad_bancaria_id int8 NULL, importe_maximo numeric(12, 2) NULL, plazo_meses int4 NULL, detalles text NULL, CONSTRAINT alquiler_contrato_aval_check CHECK (((tipo_avaliador_id IS NOT NULL) AND (((persona_id IS NOT NULL) AND (juridica_id IS NULL)) OR ((persona_id IS NULL) AND (juridica_id IS NOT NULL)) OR (entidad_bancaria_id IS NOT NULL)))), CONSTRAINT alquiler_contrato_aval_pkey PRIMARY KEY (id), CONSTRAINT alquiler_contrato_aval_contrato_id_fkey FOREIGN KEY (contrato_id) REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE, CONSTRAINT alquiler_contrato_aval_entidad_bancaria_id_fkey FOREIGN KEY (entidad_bancaria_id) REFERENCES proparcon.entidad_bancaria(id), CONSTRAINT alquiler_contrato_aval_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id), CONSTRAINT alquiler_contrato_aval_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id), CONSTRAINT alquiler_contrato_aval_tipo_avaliador_id_fkey FOREIGN KEY (tipo_avaliador_id) REFERENCES proparcon.cat_tipo_avaliador(id));

-- Permissions

ALTER TABLE proparcon.alquiler_contrato_aval OWNER TO "admin";
GRANT ALL ON TABLE proparcon.alquiler_contrato_aval TO "admin";


-- proparcon.alquiler_contrato_inquilino definition

-- Drop table

-- DROP TABLE proparcon.alquiler_contrato_inquilino;

CREATE TABLE proparcon.alquiler_contrato_inquilino ( id int8 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL, contrato_id int8 NOT NULL, persona_id int8 NULL, juridica_id int8 NULL, es_titular bool DEFAULT false NOT NULL, CONSTRAINT alquiler_contrato_inquilino_check CHECK ((((persona_id IS NOT NULL) AND (juridica_id IS NULL)) OR ((persona_id IS NULL) AND (juridica_id IS NOT NULL)))), CONSTRAINT alquiler_contrato_inquilino_pkey PRIMARY KEY (id), CONSTRAINT uq_contrato_inquilino UNIQUE (contrato_id, persona_id) DEFERRABLE, CONSTRAINT alquiler_contrato_inquilino_contrato_id_fkey FOREIGN KEY (contrato_id) REFERENCES proparcon.alquiler_contrato(id) ON DELETE CASCADE, CONSTRAINT alquiler_contrato_inquilino_juridica_id_fkey FOREIGN KEY (juridica_id) REFERENCES proparcon.juridica(id), CONSTRAINT alquiler_contrato_inquilino_persona_id_fkey FOREIGN KEY (persona_id) REFERENCES proparcon.persona(id));

-- Permissions

ALTER TABLE proparcon.alquiler_contrato_inquilino OWNER TO "admin";
GRANT ALL ON TABLE proparcon.alquiler_contrato_inquilino TO "admin";



-- DROP FUNCTION proparcon.fn_inmueble_de_estancia(int8);

CREATE OR REPLACE FUNCTION proparcon.fn_inmueble_de_estancia(in_estancia_id bigint)
 RETURNS bigint
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE v_inmueble_id bigint;
BEGIN
  SELECT e.inmueble_id INTO v_inmueble_id FROM proparcon.estancia e WHERE e.id = in_estancia_id;
  RETURN v_inmueble_id;
END; $function$
;

-- Permissions

ALTER FUNCTION proparcon.fn_inmueble_de_estancia(int8) OWNER TO "admin";
GRANT ALL ON FUNCTION proparcon.fn_inmueble_de_estancia(int8) TO "admin";

-- DROP PROCEDURE proparcon.sp_demo_final(date, date, numeric, date, date, numeric);

CREATE OR REPLACE PROCEDURE proparcon.sp_demo_final(IN p_oferta_inicio date DEFAULT '2025-11-01'::date, IN p_oferta_fin date DEFAULT NULL::date, IN p_oferta_renta numeric DEFAULT 850, IN p_contrato_inicio date DEFAULT '2025-12-01'::date, IN p_contrato_fin date DEFAULT NULL::date, IN p_contrato_renta numeric DEFAULT 900)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
  -- Objetos principales de la demo
  v_estancia    bigint;   -- estancia objetivo (id=6 si existe; si no, la primera)
  v_inmueble    bigint;   -- inmueble asociado a la estancia objetivo
  v_contrato    bigint;   -- contrato demo insertado/seleccionado
  v_persona     bigint;   -- persona demo a asociar como inquilino

  -- Mecanismos de asociación de inquilino
  v_col_inq     text;     -- columna directa (si existe)
  v_tbl_p1      regclass := to_regclass('proparcon.alquiler_contrato_inquilino');   -- (contrato_id, persona_id)
  v_tbl_p2      regclass := to_regclass('proparcon.alquiler_contrato_persona');     -- (contrato_id, persona_id, rol)

  -- Auxiliares
  v_count_est   int;
BEGIN
  -- ============================================================
  -- 1) Saneamiento de rangos incoherentes (no romper CHECKs)
  --    - Alinea fecha_baja < fecha_alta → fecha_baja = fecha_alta
  --    - Alinea fecha_fin < fecha_inicio → fecha_fin = fecha_inicio y activo = FALSE
  -- ============================================================
  UPDATE proparcon.alquiler_oferta
     SET fecha_baja = fecha_alta
   WHERE fecha_baja IS NOT NULL AND fecha_baja < fecha_alta;

  UPDATE proparcon.alquiler_contrato
     SET fecha_fin = fecha_inicio, activo = FALSE
   WHERE fecha_fin IS NOT NULL AND fecha_fin < fecha_inicio;

  -- ============================================================
  -- 2) Garantizar inmueble + estancia
  --    - Si no hay estancias, intenta crear inmueble por defecto y una estancia.
  --    - Si tu tabla inmueble tiene NOT NULLs obligatorios, lanza error claro.
  -- ============================================================
  SELECT COUNT(*) INTO v_count_est FROM proparcon.estancia;
  IF v_count_est = 0 THEN
    BEGIN
      INSERT INTO proparcon.inmueble DEFAULT VALUES RETURNING id INTO v_inmueble;
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear un inmueble con DEFAULT VALUES (NOT NULL requerido). Crea manualmente un inmueble con sus campos obligatorios y vuelve a ejecutar.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando inmueble por defecto (%). Crea uno manualmente y reintenta.', SQLERRM;
    END;

    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id) VALUES (v_inmueble);
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear estancia por defecto (NOT NULL en estancia). Indica columnas requeridas.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando estancia por defecto (%).', SQLERRM;
    END;
  END IF;

  -- ============================================================
  -- 3) Estancia objetivo: id=6 si existe; si no, la primera
  -- ============================================================
  SELECT COALESCE((SELECT 6 WHERE EXISTS (SELECT 1 FROM proparcon.estancia WHERE id=6)),
                  (SELECT MIN(id) FROM proparcon.estancia))
  INTO v_estancia;

  -- Inmueble de la estancia objetivo
  SELECT inmueble_id INTO v_inmueble
  FROM proparcon.estancia
  WHERE id = v_estancia;

  -- ============================================================
  -- 4) Cerrar activos HOY a nivel de inmueble (seguro para CHECKs)
  --    - Ofertas: fecha_baja = COALESCE(fecha_baja, ayer) si siguen activas hoy
  --    - Contratos: fecha_fin = COALESCE(fecha_fin, ayer), activo = FALSE si siguen activos hoy
  -- ============================================================
  UPDATE proparcon.alquiler_oferta o
     SET fecha_baja = COALESCE(o.fecha_baja, CURRENT_DATE - 1)
   WHERE o.estancia_id IN (SELECT id FROM proparcon.estancia WHERE inmueble_id = v_inmueble)
     AND COALESCE(o.fecha_baja, DATE '9999-12-31') >= CURRENT_DATE;

  UPDATE proparcon.alquiler_contrato c
     SET fecha_fin = COALESCE(c.fecha_fin, CURRENT_DATE - 1),
         activo    = FALSE
   WHERE c.estancia_id IN (SELECT id FROM proparcon.estancia WHERE inmueble_id = v_inmueble)
     AND COALESCE(c.fecha_fin, DATE '9999-12-31') >= CURRENT_DATE;

  -- ============================================================
  -- 5) Insertar OFERTA demo (idempotente por solape de rangos)
  -- ============================================================
  INSERT INTO proparcon.alquiler_oferta (estancia_id, fecha_alta, fecha_baja, renta_mensual)
  SELECT v_estancia, p_oferta_inicio, p_oferta_fin, p_oferta_renta
  WHERE NOT EXISTS (
    SELECT 1
    FROM proparcon.alquiler_oferta o
    WHERE o.estancia_id = v_estancia
      AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]')
          && daterange(p_oferta_inicio, COALESCE(p_oferta_fin, DATE '9999-12-31'), '[]')
  );

  -- ============================================================
  -- 6) Insertar CONTRATO demo (idempotente) como INACTIVO
  --    - Luego se asocia inquilino y se activa
  -- ============================================================
  INSERT INTO proparcon.alquiler_contrato (estancia_id, fecha_inicio, fecha_fin, renta_mensual, activo)
  SELECT v_estancia, p_contrato_inicio, p_contrato_fin, p_contrato_renta, FALSE
  WHERE NOT EXISTS (
    SELECT 1
    FROM proparcon.alquiler_contrato c
    WHERE c.estancia_id = v_estancia
      AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]')
          && daterange(p_contrato_inicio, COALESCE(p_contrato_fin, DATE '9999-12-31'), '[]')
  );

  -- Localizar el contrato de demo
  SELECT id INTO v_contrato
  FROM proparcon.alquiler_contrato
  WHERE estancia_id = v_estancia
    AND fecha_inicio = p_contrato_inicio
  ORDER BY id DESC
  LIMIT 1;

  IF v_contrato IS NULL THEN
    RAISE EXCEPTION 'sp_demo_final: no se encontró el contrato de demo (estancia %, inicio %).', v_estancia, p_contrato_inicio;
  END IF;

  -- ============================================================
  -- 7) Persona demo (o la primera existente)
  --    - Si tu tabla persona tiene NOT NULLs, puedes adaptar aquí valores por defecto
  -- ============================================================
  SELECT id INTO v_persona
  FROM proparcon.persona
  ORDER BY id
  LIMIT 1;

  IF v_persona IS NULL THEN
    BEGIN
      INSERT INTO proparcon.persona DEFAULT VALUES RETURNING id INTO v_persona;
    EXCEPTION
      WHEN not_null_violation THEN
        RAISE EXCEPTION 'sp_demo_final: no se pudo crear persona demo con DEFAULT VALUES (NOT NULL). Indica columnas requeridas y reintenta.';
      WHEN OTHERS THEN
        RAISE EXCEPTION 'sp_demo_final: error creando persona demo (%).', SQLERRM;
    END;
  END IF;

  -- ============================================================
  -- 8) Asociar INQUILINO al contrato
  --    - Prioridad: tabla puente v1 → tabla puente v2 → columna directa
  -- ============================================================
  SELECT CASE
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon'
                          AND table_name='alquiler_contrato'
                          AND column_name='inquilino_persona_id')    THEN 'inquilino_persona_id'
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon'
                          AND table_name='alquiler_contrato'
                          AND column_name='arrendatario_persona_id') THEN 'arrendatario_persona_id'
           ELSE NULL
         END
  INTO v_col_inq;

  IF v_tbl_p1 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_inquilino (contrato_id, persona_id)
    SELECT v_contrato, v_persona
    WHERE NOT EXISTS (
      SELECT 1
      FROM proparcon.alquiler_contrato_inquilino
      WHERE contrato_id = v_contrato
        AND persona_id  = v_persona
    );

  ELSIF v_tbl_p2 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_persona (contrato_id, persona_id, rol)
    SELECT v_contrato, v_persona, 'inquilino'
    WHERE NOT EXISTS (
      SELECT 1
      FROM proparcon.alquiler_contrato_persona
      WHERE contrato_id = v_contrato
        AND persona_id  = v_persona
        AND (rol = 'inquilino' OR rol IS NULL)
    );

  ELSIF v_col_inq IS NOT NULL THEN
    EXECUTE format('UPDATE proparcon.alquiler_contrato SET %I = $1 WHERE id = $2', v_col_inq)
    USING v_persona, v_contrato;

  ELSE
    -- Si no hay forma de asociar inquilino, no activamos para no violar triggers
    RAISE NOTICE 'sp_demo_final: no hay tabla puente ni columna directa para inquilinos; el contrato quedará INACTIVO.';
    RETURN;
  END IF;

  -- ============================================================
  -- 9) Activar contrato (ya con ≥1 inquilino asociado)
  -- ============================================================
  UPDATE proparcon.alquiler_contrato
     SET activo = TRUE
   WHERE id = v_contrato;

  RAISE NOTICE 'DEMO FINAL OK · Estancia % · Contrato % · Inquilino %',
               v_estancia, v_contrato, v_persona;
END;
$procedure$
;

-- Permissions

ALTER PROCEDURE proparcon.sp_demo_final(date, date, numeric, date, date, numeric) OWNER TO "admin";
GRANT ALL ON PROCEDURE proparcon.sp_demo_final(date, date, numeric, date, date, numeric) TO "admin";

-- DROP PROCEDURE proparcon.sp_demo_more_data();

CREATE OR REPLACE PROCEDURE proparcon.sp_demo_more_data()
 LANGUAGE plpgsql
AS $procedure$
DECLARE
  -- Fechas objetivo
  v_oferta_fecha date := DATE '2026-01-10';
  v_ctr_inicio   date := DATE '2026-02-01';

  -- Inmuebles candidatos (libres)
  v_inmA bigint;  -- para oferta
  v_inmB bigint;  -- para contrato

  -- Estancias objetivo (nuevas o fallback a existentes)
  v_estA bigint;
  v_estB bigint;

  -- Persona demo
  v_pers bigint;

  -- Contrato B
  v_contratoB bigint;

  -- Asociación
  v_tbl_p1 regclass := to_regclass('proparcon.alquiler_contrato_inquilino');
  v_tbl_p2 regclass := to_regclass('proparcon.alquiler_contrato_persona');
  v_col_inq text;

  v_has_final boolean := (to_regprocedure('proparcon.sp_demo_final()') IS NOT NULL);
BEGIN
  -- 0) Asegurar base mínima (si no hay inmuebles)
  IF NOT EXISTS (SELECT 1 FROM proparcon.inmueble) THEN
    IF v_has_final THEN
      CALL proparcon.sp_demo_final();
    END IF;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM proparcon.inmueble) THEN
    RAISE NOTICE 'MORE_DATA: no hay inmuebles; se omiten escenarios.';
    RETURN;
  END IF;

  -- 1) Buscar inmueble libre para v_oferta_fecha
  WITH inm_libres AS (
    SELECT i.id
    FROM proparcon.inmueble i
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_oferta o ON o.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]') @> v_oferta_fecha
    )
    AND NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_contrato c ON c.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]') @> v_oferta_fecha
    )
    ORDER BY i.id
  )
  SELECT id INTO v_inmA FROM inm_libres LIMIT 1;

  IF v_inmA IS NULL THEN
    RAISE NOTICE 'MORE_DATA: sin inmueble libre para OFERTA en %; omito escenario A.', v_oferta_fecha;
  END IF;

  -- 2) Buscar inmueble libre para v_ctr_inicio (distinto de A si hay)
  WITH inm_libres AS (
    SELECT i.id
    FROM proparcon.inmueble i
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_oferta o ON o.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(o.fecha_alta, COALESCE(o.fecha_baja, DATE '9999-12-31'), '[]') @> v_ctr_inicio
    )
    AND NOT EXISTS (
      SELECT 1 FROM proparcon.estancia e
      JOIN proparcon.alquiler_contrato c ON c.estancia_id = e.id
      WHERE e.inmueble_id = i.id
        AND daterange(c.fecha_inicio, COALESCE(c.fecha_fin, DATE '9999-12-31'), '[]') @> v_ctr_inicio
    )
    ORDER BY i.id
  )
  SELECT id INTO v_inmB FROM inm_libres
  WHERE (v_inmA IS NULL OR id <> v_inmA)
  LIMIT 1;

  IF v_inmB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: sin inmueble libre para CONTRATO en %; omito escenario B.', v_ctr_inicio;
  END IF;

  IF v_inmA IS NULL AND v_inmB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: no hay hueco libre en inmuebles; no se inserta nada.';
    RETURN;
  END IF;

  -- 3) Estancia A (crear o fallback)
  IF v_inmA IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id)
      VALUES (v_inmA)
      RETURNING id INTO v_estA;
    EXCEPTION WHEN not_null_violation THEN
      SELECT id INTO v_estA
      FROM proparcon.estancia
      WHERE inmueble_id = v_inmA
      ORDER BY id
      LIMIT 1;
      IF v_estA IS NULL THEN
        RAISE NOTICE 'MORE_DATA: sin estancia utilizable en inmueble % (A); omito escenario A.', v_inmA;
      END IF;
    END;
  END IF;

  -- 4) Estancia B (crear o fallback)
  IF v_inmB IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.estancia (inmueble_id)
      VALUES (v_inmB)
      RETURNING id INTO v_estB;
    EXCEPTION WHEN not_null_violation THEN
      SELECT id INTO v_estB
      FROM proparcon.estancia
      WHERE inmueble_id = v_inmB
      ORDER BY id
      LIMIT 1;
      IF v_estB IS NULL THEN
        RAISE NOTICE 'MORE_DATA: sin estancia utilizable en inmueble % (B); omito escenario B.', v_inmB;
      END IF;
    END;
  END IF;

  IF v_estA IS NULL AND v_estB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: no hay estancias objetivo; no se inserta nada.';
    RETURN;
  END IF;

  -- 5) Escenario A: OFERTA (con guarda a nivel INMUEBLE + try/catch)
  IF v_estA IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.alquiler_oferta (estancia_id, fecha_alta, fecha_baja, renta_mensual)
      SELECT v_estA, v_oferta_fecha, NULL, 700
      WHERE NOT EXISTS (  -- idempotencia por estancia+fecha exacta
        SELECT 1 FROM proparcon.alquiler_oferta
        WHERE estancia_id = v_estA
          AND fecha_alta   = v_oferta_fecha
      )
      AND NOT EXISTS (   -- GUARDA: inmueble libre para esa fecha (ofertas y contratos)
        SELECT 1
        FROM proparcon.estancia e2
        JOIN proparcon.alquiler_oferta o2 ON o2.estancia_id = e2.id
        WHERE e2.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estA)
          AND daterange(o2.fecha_alta, COALESCE(o2.fecha_baja, DATE '9999-12-31'), '[]') @> v_oferta_fecha
      )
      AND NOT EXISTS (
        SELECT 1
        FROM proparcon.estancia e3
        JOIN proparcon.alquiler_contrato c2 ON c2.estancia_id = e3.id
        WHERE e3.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estA)
          AND daterange(c2.fecha_inicio, COALESCE(c2.fecha_fin, DATE '9999-12-31'), '[]') @> v_oferta_fecha
      );
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'MORE_DATA(A): se omitió la oferta por exclusión/trigger: %', SQLERRM;
    END;
  END IF;

  -- 6) Escenario B: CONTRATO (idempotente, inactivo; guarda + try/catch)
  IF v_estB IS NOT NULL THEN
    BEGIN
      INSERT INTO proparcon.alquiler_contrato (estancia_id, fecha_inicio, fecha_fin, renta_mensual, activo)
      SELECT v_estB, v_ctr_inicio, NULL, 950, FALSE
      WHERE NOT EXISTS (  -- idempotencia por estancia+fecha exacta
        SELECT 1 FROM proparcon.alquiler_contrato
        WHERE estancia_id = v_estB
          AND fecha_inicio = v_ctr_inicio
      )
      AND NOT EXISTS (   -- GUARDA: inmueble libre para esa fecha (ofertas y contratos)
        SELECT 1
        FROM proparcon.estancia e2
        JOIN proparcon.alquiler_oferta o2 ON o2.estancia_id = e2.id
        WHERE e2.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estB)
          AND daterange(o2.fecha_alta, COALESCE(o2.fecha_baja, DATE '9999-12-31'), '[]') @> v_ctr_inicio
      )
      AND NOT EXISTS (
        SELECT 1
        FROM proparcon.estancia e3
        JOIN proparcon.alquiler_contrato c2 ON c2.estancia_id = e3.id
        WHERE e3.inmueble_id = (SELECT inmueble_id FROM proparcon.estancia WHERE id = v_estB)
          AND daterange(c2.fecha_inicio, COALESCE(c2.fecha_fin, DATE '9999-12-31'), '[]') @> v_ctr_inicio
      );
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'MORE_DATA(B): se omitió el contrato por exclusión/trigger: %', SQLERRM;
    END;
  END IF;

  -- 7) Si no se generó contrato B, terminar (escenario A pudo quedar OK)
  SELECT id INTO v_contratoB
  FROM proparcon.alquiler_contrato
  WHERE estancia_id = v_estB
    AND fecha_inicio = v_ctr_inicio
  ORDER BY id DESC
  LIMIT 1;

  IF v_contratoB IS NULL THEN
    RAISE NOTICE 'MORE_DATA: escenario A=% (estancia=%). Escenario B omitido.',
                 (v_estA IS NOT NULL), v_estA;
    RETURN;
  END IF;

  -- 8) Persona demo (o la primera)
  SELECT id INTO v_pers FROM proparcon.persona ORDER BY id LIMIT 1;
  IF v_pers IS NULL THEN
    INSERT INTO proparcon.persona DEFAULT VALUES RETURNING id INTO v_pers;
  END IF;

  -- 9) Asociar inquilino (puente1 → puente2 → columna directa)
  SELECT CASE
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon' AND table_name='alquiler_contrato'
                          AND column_name='inquilino_persona_id')    THEN 'inquilino_persona_id'
           WHEN EXISTS (SELECT 1 FROM information_schema.columns
                        WHERE table_schema='proparcon' AND table_name='alquiler_contrato'
                          AND column_name='arrendatario_persona_id') THEN 'arrendatario_persona_id'
           ELSE NULL
         END INTO v_col_inq;

  IF v_tbl_p1 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_inquilino (contrato_id, persona_id)
    SELECT v_contratoB, v_pers
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.alquiler_contrato_inquilino
      WHERE contrato_id = v_contratoB AND persona_id = v_pers
    );
  ELSIF v_tbl_p2 IS NOT NULL THEN
    INSERT INTO proparcon.alquiler_contrato_persona (contrato_id, persona_id, rol)
    SELECT v_contratoB, v_pers, 'inquilino'
    WHERE NOT EXISTS (
      SELECT 1 FROM proparcon.alquiler_contrato_persona
      WHERE contrato_id = v_contratoB
        AND persona_id  = v_pers
        AND (rol = 'inquilino' OR rol IS NULL)
    );
  ELSIF v_col_inq IS NOT NULL THEN
    EXECUTE format('UPDATE proparcon.alquiler_contrato SET %I=$1 WHERE id=$2', v_col_inq)
    USING v_pers, v_contratoB;
  ELSE
    RAISE NOTICE 'MORE_DATA: sin mecanismo de asociación de inquilino; contrato permanece INACTIVO.';
    RETURN;
  END IF;

  -- 10) Activar contrato B
  UPDATE proparcon.alquiler_contrato SET activo = TRUE WHERE id = v_contratoB;

  -- 11) Log final
  RAISE NOTICE 'MORE_DATA OK · InmuebleA=%(EstanciaA=%) · InmuebleB=%(EstanciaB=%, ContratoB=%)',
               v_inmA, v_estA, v_inmB, v_estB, v_contratoB;
END;
$procedure$
;

-- Permissions

ALTER PROCEDURE proparcon.sp_demo_more_data() OWNER TO "admin";
GRANT ALL ON PROCEDURE proparcon.sp_demo_more_data() TO "admin";

-- DROP FUNCTION proparcon.trg_assert_contrato_tiene_inquilino_titular();

CREATE OR REPLACE FUNCTION proparcon.trg_assert_contrato_tiene_inquilino_titular()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE 
  v_count int;
  v_activo_id int;
BEGIN
  -- 1. Obtener el ID del estado 'ACTIVO'
  SELECT id INTO v_activo_id FROM proparcon.cat_estado_contrato WHERE codigo = 'ACTIVO';

  -- 2. Solo ejecutar el chequeo si el nuevo estado es 'ACTIVO'
  IF NEW.estado_id = v_activo_id THEN
    -- Contamos inquilinos que tienen es_titular = TRUE.
    SELECT COUNT(*) INTO v_count
    FROM proparcon.alquiler_contrato_inquilino i
    WHERE i.contrato_id = NEW.id
      AND i.es_titular IS TRUE;

    IF v_count < 1 THEN
      RAISE EXCEPTION 'El contrato debe tener al menos un inquilino titular para pasar a ACTIVO.'
        USING HINT = 'Regla de Negocio (3. Reglas de Negocio): Un contrato ACTIVO requiere un titular.';
    END IF;
  END IF; -- Si no es ACTIVO, la función retorna sin hacer nada.
  
  RETURN NEW;
END; $function$
;

-- Permissions

ALTER FUNCTION proparcon.trg_assert_contrato_tiene_inquilino_titular() OWNER TO "admin";
GRANT ALL ON FUNCTION proparcon.trg_assert_contrato_tiene_inquilino_titular() TO "admin";

-- DROP FUNCTION proparcon.trg_check_exclusion_alquiler_estancia();

CREATE OR REPLACE FUNCTION proparcon.trg_check_exclusion_alquiler_estancia()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_estancia bigint;
  v_count int;
  v_activo_id int;
BEGIN
  v_estancia := NEW.estancia_id;
  SELECT id INTO v_activo_id FROM proparcon.cat_estado_contrato WHERE codigo = 'ACTIVO';
  
  -- Solo se verifica si el nuevo estado es ACTIVO (ID 2).
  IF NEW.estado_id = v_activo_id THEN
    SELECT COUNT(*)
    INTO v_count
    FROM proparcon.alquiler_contrato ac
    WHERE ac.estancia_id = v_estancia
      AND ac.estado_id = v_activo_id
      AND ac.id <> COALESCE(NEW.id, 0);

    IF v_count > 0 THEN
      RAISE EXCEPTION 'Ya existe un contrato ACTIVO en la estancia %.', v_estancia
        USING HINT = 'La regla de negocio (2. Reglas de Negocio) impide dos contratos ACTIVO en la misma estancia.';
    END IF;
  END IF;
  
  RETURN NEW;
END; $function$
;

-- Permissions

ALTER FUNCTION proparcon.trg_check_exclusion_alquiler_estancia() OWNER TO "admin";
GRANT ALL ON FUNCTION proparcon.trg_check_exclusion_alquiler_estancia() TO "admin";

-- DROP FUNCTION proparcon.trg_check_propiedades_100();

CREATE OR REPLACE FUNCTION proparcon.trg_check_propiedades_100()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_inmueble bigint;
  v_sum_usufructo numeric(7,2);
  v_sum_nuda numeric(7,2);
  v_sum_pleno numeric(7,2);
BEGIN
  IF TG_OP = 'DELETE' THEN v_inmueble := OLD.inmueble_id; ELSE v_inmueble := NEW.inmueble_id; END IF;

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_usufructo
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'USUFRUCTO';

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_nuda
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'NUDA';

  SELECT COALESCE(SUM(ip.porcentaje),0) INTO v_sum_pleno
  FROM proparcon.inmueble_propiedad ip
  JOIN proparcon.cat_tipo_derecho_propiedad t ON t.id = ip.tipo_derecho_id
  WHERE ip.inmueble_id = v_inmueble AND t.codigo = 'PLENO';

  IF v_sum_pleno > 100 THEN
    RAISE EXCEPTION 'Pleno dominio (%.2f) excede 100%% en inmueble %', v_sum_pleno, v_inmueble;
  END IF;
  IF (v_sum_usufructo + v_sum_pleno) > 100 THEN
    RAISE EXCEPTION 'Usufructo+Pleno (%.2f) excede 100%% en inmueble %', (v_sum_usufructo + v_sum_pleno), v_inmueble;
  END IF;
  IF (v_sum_nuda + v_sum_pleno) > 100 THEN
    RAISE EXCEPTION 'Nuda+Pleno (%.2f) excede 100%% en inmueble %', (v_sum_nuda + v_sum_pleno), v_inmueble;
  END IF;

  RETURN COALESCE(NEW, OLD);
END; $function$
;

-- Permissions

ALTER FUNCTION proparcon.trg_check_propiedades_100() OWNER TO "admin";
GRANT ALL ON FUNCTION proparcon.trg_check_propiedades_100() TO "admin";


-- Permissions

GRANT ALL ON SCHEMA proparcon TO "admin";

--- ARCHIVO: sql\seed_ciclo1_minimo.sql ---
-- === CICLO 1 · Datos mínimos coherentes ===
SET search_path TO proparcon;

-- 1️⃣ Personas
INSERT INTO persona (id, nombre, apellidos, dni, telefono)
VALUES
 (1,'María','Pérez Gómez','12345678A','600111222'),
 (2,'Juan','López Martín','87654321B','600333444');

-- 2️⃣ Propiedad 50 / 50 del inmueble 1
INSERT INTO inmueble_propiedad (id, inmueble_id, persona_id, tipo_derecho_id, porcentaje)
VALUES
 (1,1,1,1,50),
 (2,1,2,1,50);

-- 3️⃣ Estancia principal del inmueble 1
INSERT INTO estancia (id, inmueble_id, tipo_estancia_id, nombre, superficie)
VALUES
 (1,1,1,'Vivienda principal',85);

-- 4️⃣ Oferta activa sobre esa estancia
INSERT INTO alquiler_oferta
 (id, estancia_id, estado_id, renta_mensual, gestor_persona_id, encargado_persona_id, fecha_alta)
VALUES
 (1,1,1,850.00,1,2,CURRENT_DATE);

=== ESTRUCTURA FRONTEND (React) ===


--- ARCHIVO: vite.config.ts ---
// vite.config.ts
// Comentario: configuración mínima de Vite con React y TS
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    watch: {
      usePolling: true, // Vital para Docker en algunos sistemas
    },
    host: true, // Esto complementa tu comando de Docker
    strictPort: true,
    port: 5173,
  }
})

--- ARCHIVO: src\api.ts ---
/// <reference types="vite/client" />
/**
 * =============================================================================
 * api.ts — Cliente HTTP + Auth helpers (React/Vite)
 * =============================================================================
 * Objetivo:
 *  - Cliente HTTP basado en fetch (sin axios).
 *  - Inyección automática de Bearer token (salvo que se desactive por request).
 *  - Helpers: apiGet/apiPost/apiPatch/apiDelete.
 *  - Auth: apiLogin (JSON body), apiLogout.
 *  - JWT helpers (solo UI): getJwtPayload/getCurrentUserRole (NO valida firma).
 *
 * Nota importante (causa típica del 422 en login):
 *  - El backend (FastAPI) espera JSON: { "email": "...", "password": "..." }.
 *  - Si envías "username=...&password=..." (form-urlencoded), FastAPI devuelve 422.
 * =============================================================================
 */

/** Marcador para verificar que el frontend está cargando ESTA versión del fichero */
export const API_TS_MARKER = "API_TS_MARKER__JSON_LOGIN__2026-01-12__A";

/* =============================================================================
 * Sección 1: Tipos y errores normalizados
 * ============================================================================= */

export type HttpMethod = "GET" | "POST" | "PATCH" | "DELETE";

/** Payload de error típico para APIs FastAPI */
export type ApiErrorPayload = {
  detail?: unknown;
  message?: string;
  error?: string;
};

/** Error normalizado para capa UI */
export class ApiError extends Error {
  status: number;
  payload?: unknown;

  constructor(message: string, status: number, payload?: unknown) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.payload = payload;
  }
}

/** Opciones por request */
export type ApiRequestOptions = {
  /**
   * Por defecto true.
   * En login conviene false para no adjuntar un Bearer viejo.
   */
  auth?: boolean;

  /**
   * Forzar content-type si quieres algo distinto del default.
   * (Por defecto: JSON si hay body y no es FormData)
   */
  contentType?: "application/json" | "application/x-www-form-urlencoded";
};

/* =============================================================================
 * Sección 2: Config / Token helpers
 * ============================================================================= */

function getApiBaseUrl(): string {
  // Prioridad: variables Vite -> fallback local
  const envBase =
    import.meta.env.VITE_API_BASE_URL ??
    import.meta.env.VITE_API_URL ??
    "http://localhost:8000";

  return String(envBase).replace(/\/+$/, "");
}

export function getToken(): string | null {
  const token = localStorage.getItem("token");
  if (!token || token === "null" || token === "undefined") return null;
  return token;
}

export function setToken(token: string) {
  localStorage.setItem("token", token);
}

/* =============================================================================
 * Sección 3: HTTP core (fetch) + parseo de respuestas
 * ============================================================================= */

async function parseResponse<T>(res: Response): Promise<T> {
  // 204 No Content
  if (res.status === 204) return undefined as unknown as T;

  const contentType = res.headers.get("content-type") || "";

  // JSON
  if (contentType.includes("application/json")) {
    return (await res.json()) as T;
  }

  // Texto / otros
  const txt = await res.text();
  return txt as unknown as T;
}

async function apiRequest<T>(
  method: HttpMethod,
  path: string,
  body?: unknown,
  options: ApiRequestOptions = {}
): Promise<T> {
  const baseUrl = getApiBaseUrl();
  const url = `${baseUrl}${path.startsWith("/") ? "" : "/"}${path}`;

  const authEnabled = options.auth !== false;

  // --- headers base
  const headers: Record<string, string> = {};

  // --- bearer token
  if (authEnabled) {
    const token = getToken();
    if (token) headers.Authorization = `Bearer ${token}`;
  }

  const hasBody = body !== undefined && body !== null && method !== "GET";

  // --- content-type: por defecto JSON si hay body, salvo FormData
  if (hasBody && !(body instanceof FormData)) {
    headers["Content-Type"] =
      options.contentType ?? "application/json";
  }

  const init: RequestInit = {
    method,
    headers,
  };

  // --- body mapping
  if (hasBody) {
    if (body instanceof FormData) {
      // Importante: no setear Content-Type; el browser pone boundary
      init.body = body;
    } else if (
      typeof body === "string" &&
      headers["Content-Type"] === "application/x-www-form-urlencoded"
    ) {
      init.body = body;
    } else if (headers["Content-Type"] === "application/json") {
      init.body = JSON.stringify(body);
    } else {
      // fallback (no debería usarse normalmente)
      init.body = body as any;
    }
  }

  const res = await fetch(url, init);

  if (!res.ok) {
    const payload = await parseResponse<ApiErrorPayload>(res).catch(
      () => undefined
    );
    throw new ApiError(
      `HTTP ${res.status} ${res.statusText}`,
      res.status,
      payload
    );
  }

  return parseResponse<T>(res);
}

/* =============================================================================
 * Sección 4: Helpers REST
 * ============================================================================= */

export function apiGet<T>(path: string, options?: ApiRequestOptions) {
  return apiRequest<T>("GET", path, undefined, options ?? {});
}

export function apiPost<T>(path: string, body?: unknown, options?: ApiRequestOptions) {
  return apiRequest<T>("POST", path, body, options ?? {});
}

export function apiPatch<T>(path: string, body?: unknown, options?: ApiRequestOptions) {
  return apiRequest<T>("PATCH", path, body, options ?? {});
}

export function apiDelete<T>(path: string, options?: ApiRequestOptions) {
  return apiRequest<T>("DELETE", path, undefined, options ?? {});
}

/* =============================================================================
 * Sección 5: Auth (Login / Logout)
 * ============================================================================= */

export type LoginResponse = {
  access_token: string;
  token_type?: string;
  role?: string;
};

/**
 * Login para FastAPI (Pydantic JSON).
 * IMPORTANTE: el backend espera un JSON tipo: { "email": "...", "password": "..." }
 */
export async function apiLogin(email: string, password: string): Promise<LoginResponse> {
  const data = await apiRequest<LoginResponse>(
    "POST",
    "/v1/auth/login",
    { email, password },
    { auth: false, contentType: "application/json" }
  );

  if (!data?.access_token) {
    throw new ApiError("Respuesta de login inválida (sin access_token)", 500, data);
  }

  setToken(data.access_token);
  return data;
}

export function apiLogout() {
  // Limpieza mínima (ajusta si usas otras claves)
  localStorage.removeItem("token");
  localStorage.removeItem("access_token"); // por si quedó de pruebas
  localStorage.removeItem("user");

  // Redirección “limpia”
  window.location.replace("/");
}

/* =============================================================================
 * Sección 6: JWT helpers (solo UI — NO valida firma)
 * ============================================================================= */

function base64UrlToBase64(input: string): string {
  const base64 = input.replace(/-/g, "+").replace(/_/g, "/");
  return base64 + "=".repeat((4 - (base64.length % 4)) % 4);
}

function safeAtob(base64: string): string | null {
  try {
    return atob(base64);
  } catch {
    return null;
  }
}

function decodeUtf8FromBinaryString(binary: string): string {
  // Convierte "binary string" a UTF-8 correcto (atob devuelve bytes 0..255)
  try {
    return decodeURIComponent(
      binary
        .split("")
        .map((c) => "%" + c.charCodeAt(0).toString(16).padStart(2, "0"))
        .join("")
    );
  } catch {
    return binary;
  }
}

export function getJwtPayload<
  T extends Record<string, unknown> = Record<string, unknown>
>(): T | null {
  const token = getToken();
  if (!token) return null;

  const parts = token.split(".");
  if (parts.length !== 3) return null;

  const payloadB64 = base64UrlToBase64(parts[1]);
  const decoded = safeAtob(payloadB64);
  if (!decoded) return null;

  const json = decodeUtf8FromBinaryString(decoded);

  try {
    return JSON.parse(json) as T;
  } catch {
    return null;
  }
}

export function getCurrentUserRole(): string | null {
  const payload = getJwtPayload<{ role?: unknown }>();
  const role = payload?.role;

  if (role == null) return null;

  const normalized = String(role).trim().toLowerCase();
  return normalized.length ? normalized : null;
}


--- ARCHIVO: src\App.tsx ---
/**
 * ============================================================================
 * APP COMPONENT (App.tsx)
 * ============================================================================
 * Función: Actúa como el contenedor principal de la aplicación.
 * Actualmente delega toda la lógica de navegación al Menú Principal.
 * ============================================================================
 */

import React from "react";
import ProparconMainMenu from "./ProparconMainMenu";

export default function App() {
  return (
    // Contenedor principal con fondo suave para toda la web
    <div className="min-h-screen bg-slate-50 text-slate-900">
      <ProparconMainMenu />
    </div>
  );
}


--- ARCHIVO: src\main.tsx ---
/**
 * ============================================================================
 * ARCHIVO: main.tsx
 * ============================================================================
 * DESCRIPCIÓN: Punto de entrada raíz de React.
 * SECCIÓN: CONTROL DE ACCESO - Decide qué componente principal mostrar.
 * ============================================================================
 */
import React from 'react';
import ReactDOM from 'react-dom/client';
import ProparconLogin from './ProparconLogin';
import ProparconMainMenu from './ProparconMainMenu';

const RootApp = () => {
  // Comprobamos si el usuario tiene una sesión activa (token presente)
  const isAuthenticated = !!localStorage.getItem('token');

  return (
    <React.StrictMode>
      {isAuthenticated ? <ProparconMainMenu /> : <ProparconLogin />}
    </React.StrictMode>
  );
};

ReactDOM.createRoot(document.getElementById('root')!).render(<RootApp />);

--- ARCHIVO: src\ProparconLogin.tsx ---
/**
 * ============================================================================
 * ARCHIVO: ProparconLogin.tsx
 * ============================================================================
 * DESCRIPCIÓN: Pantalla de inicio de sesión.
 * SECCIÓN: FORMULARIO - Captura NIF/Email y contraseña.
 * ============================================================================
 */
import React, { useState } from 'react';
import { apiLogin } from './api';

const ProparconLogin: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    try {
      await apiLogin(username, password);
      // Tras éxito, el token se guarda en api.ts y recargamos main.tsx
      window.location.reload();
    } catch (err: any) {
      setError("Fallo en la autenticación. Verifique sus credenciales.");
    }
  };

  return (
    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', background: '#ecf0f1' }}>
      <form onSubmit={handleLogin} style={{ background: 'white', padding: '40px', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', width: '300px' }}>
        <h2 style={{ textAlign: 'center', color: '#2c3e50' }}>Acceso Proparcon</h2>
        <div style={{ marginBottom: '15px' }}>
          <label>Usuario (NIF/Email):</label>
          <input type="text" value={username} onChange={e => setUsername(e.target.value)} style={{ width: '100%', padding: '10px', marginTop: '5px' }} required />
        </div>
        <div style={{ marginBottom: '20px' }}>
          <label>Contraseña:</label>
          <input type="password" value={password} onChange={e => setPassword(e.target.value)} style={{ width: '100%', padding: '10px', marginTop: '5px' }} required />
        </div>
        {error && <p style={{ color: 'red', fontSize: '14px' }}>{error}</p>}
        <button type="submit" style={{ width: '100%', padding: '12px', background: '#3498db', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>
          Iniciar Sesión
        </button>
      </form>
    </div>
  );
};

export default ProparconLogin;

--- ARCHIVO: src\ProparconMainMenu.tsx ---
import { useEffect, useMemo, useState } from "react";

import InmuebleForm from "./components/InmuebleForm";
import EstanciaForm from "./components/EstanciaForm";
import OfertaForm from "./components/OfertaForm";
import PersonaForm from "./components/PersonaForm";
import PropiedadForm from "./components/PropiedadForm";
// import ContratoForm from "./components/ContratoForm";

// NUEVO: página de catálogos
import CatalogosPage from "./pages/CatalogosPage";

// NUEVO: lee role del JWT guardado en localStorage
import { apiLogout, getCurrentUserRole } from "./api";

type Tab =
  | "inmueble"
  | "estancia"
  | "oferta"
  | "persona"
  | "propiedad"
  | "contrato"
  | "catalogos";

export default function ProparconMainMenu() {
  const [selectedTab, setSelectedTab] = useState<Tab>("inmueble");

  // Leemos role desde JWT (UI only)
  const role = useMemo(() => (getCurrentUserRole() || "").toLowerCase(), []);
  const isAdmin = role === "admin";

  // Guardia: si alguien fuerza "catalogos" sin ser admin, lo devolvemos.
  useEffect(() => {
    if (selectedTab === "catalogos" && !isAdmin) {
      setSelectedTab("inmueble");
    }
  }, [selectedTab, isAdmin]);

  const renderContent = () => {
    switch (selectedTab) {
      case "inmueble":
        return <InmuebleForm />;
      case "estancia":
        return <EstanciaForm />;
      case "oferta":
        return <OfertaForm />;
      case "persona":
        return <PersonaForm />;
      case "propiedad":
        return <PropiedadForm />;
      case "contrato":
        return <div className="p-4">Contrato: pendiente de desarrollo</div>;


      // NUEVO
      case "catalogos":
        return <CatalogosPage />;

      default:
        return <InmuebleForm />;
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white border-b">
        <div className="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
          <h1 className="text-xl font-semibold text-gray-900">PROPARCON</h1>

          <div className="flex gap-2">
            <button
              className="px-3 py-2 rounded bg-gray-900 text-white hover:bg-black"
              onClick={() => apiLogout()}
              title="Cerrar sesión"
            >
              Logout
            </button>
          </div>
        </div>

        <nav className="max-w-6xl mx-auto px-4 pb-4 flex flex-wrap gap-2">
          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "inmueble" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("inmueble")}
          >
            Inmueble
          </button>

          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "estancia" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("estancia")}
          >
            Estancia
          </button>

          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "oferta" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("oferta")}
          >
            Oferta
          </button>

          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "persona" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("persona")}
          >
            Persona
          </button>

          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "propiedad" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("propiedad")}
          >
            Propiedad
          </button>

          <button
            className={`px-3 py-2 rounded border ${
              selectedTab === "contrato" ? "bg-white" : "bg-gray-100"
            }`}
            onClick={() => setSelectedTab("contrato")}
          >
            Contrato
          </button>

          {/* NUEVO: solo ADMIN ve Catálogos */}
          {isAdmin && (
            <button
              className={`px-3 py-2 rounded border ${
                selectedTab === "catalogos" ? "bg-white" : "bg-gray-100"
              }`}
              onClick={() => setSelectedTab("catalogos")}
            >
              Catálogos
            </button>
          )}
        </nav>
      </header>

      <main className="max-w-6xl mx-auto px-4 py-6">{renderContent()}</main>
    </div>
  );
}


--- ARCHIVO: src\vite-env.d.ts ---
/// <reference types="vite/client" />


--- ARCHIVO: src\components\EstanciaForm.tsx ---
/**
 * ============================================================================
 * COMPONENTE: EstanciaForm.tsx
 * DISEÑO: Jerarquía Inmueble -> Estancia con sangría y cabecera única.
 * ============================================================================
 * ACTUALIZACIÓN REALIZADA:
 * ✅ DISEÑO JERÁRQUICO: Agrupación por Inmueble.
 * ✅ SANGRÍA (ml-12): El bloque de estancias se desplaza a la derecha.
 * ✅ CABECERA ÚNICA: Solo se muestra una cabecera de tabla por inmueble.
 * ============================================================================
 */

import React, { useEffect, useState } from 'react';
import { apiGet, apiPost, apiDelete, apiPatch } from '../api';

export default function EstanciaForm() {
  const [items, setItems] = useState<any[]>([]);
  const [inmuebles, setInmuebles] = useState<any[]>([]);
  const [tipos, setTipos] = useState<any[]>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [form, setForm] = useState({ inmueble_id: '', tipo_estancia_id: '', nombre: '' });

  const load = async () => {
    try {
      const [dEst, dInm, dTipos] = await Promise.all([
        apiGet('/api/estancia'),
        apiGet('/api/inmueble'),
        apiGet('/api/estancia/tipos')
      ]);
      setItems(Array.isArray(dEst) ? dEst : []);
      setInmuebles(Array.isArray(dInm) ? dInm : []);
      setTipos(Array.isArray(dTipos) ? dTipos : []);
    } catch (e) { console.error("Error cargando estancias"); }
  };

  useEffect(() => { load(); }, []);

  // Agrupamiento por Inmueble
  const agrupados = items.reduce((acc: any, curr: any) => {
    const key = curr.inmueble_id;
    if (!acc[key]) acc[key] = { nombre: curr.inmueble_nombre, estancias: [] };
    acc[key].estancias.push(curr);
    return acc;
  }, {});

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const payload = { ...form, inmueble_id: parseInt(form.inmueble_id), tipo_estancia_id: parseInt(form.tipo_estancia_id) };
    if (editingId) await apiPatch(`/api/estancia/${editingId}`, payload);
    else await apiPost('/api/estancia', payload);
    setEditingId(null);
    setForm({ inmueble_id: '', tipo_estancia_id: '', nombre: '' });
    load();
  };

  return (
    <div className="p-6 bg-white rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold mb-6 text-green-900 border-b pb-2">Gestión de Estancias</h2>

      {/* Formulario de Entrada */}
      <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-10 bg-green-50 p-4 rounded border">
        <select value={form.inmueble_id} onChange={e => setForm({...form, inmueble_id: e.target.value})} className="p-2 border rounded" required disabled={!!editingId}>
          <option value="">Inmueble...</option>
          {inmuebles.map(i => <option key={i.id} value={i.id}>{i.nombre_publico}</option>)}
        </select>
        <select value={form.tipo_estancia_id} onChange={e => setForm({...form, tipo_estancia_id: e.target.value})} className="p-2 border rounded" required>
          <option value="">Tipo...</option>
          {tipos.map(t => <option key={t.id} value={t.id}>{t.descripcion}</option>)}
        </select>
        <input value={form.nombre} onChange={e => setForm({...form, nombre: e.target.value})} className="p-2 border rounded" placeholder="Nombre Estancia" required />
        <button type="submit" className={`p-2 rounded text-white font-bold ${editingId ? 'bg-orange-500' : 'bg-green-700'}`}>
          {editingId ? 'Actualizar' : 'Guardar'}
        </button>
      </form>

      {/* Listado con Jerarquía y Sangría */}
      <div className="space-y-10">
        {Object.keys(agrupados).map(inmId => (
          <div key={inmId}>
            {/* Cabecera de Inmueble */}
            <div className="flex items-center bg-green-800 p-3 rounded-t-lg text-white">
              <span className="text-lg font-bold">🏢 INMUEBLE: {agrupados[inmId].nombre}</span>
              <span className="ml-3 text-xs opacity-60 font-mono">(ID: {inmId})</span>
            </div>

            {/* Bloque con sangría ml-12 */}
            <div className="ml-12 border-l border-b border-r rounded-b-lg overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-gray-100 text-[10px] uppercase text-gray-500">
                  <tr>
                    <th className="p-2 text-left w-20">ID</th>
                    <th className="p-2 text-left">Estancia</th>
                    <th className="p-2 text-left">Tipo de Estancia</th>
                    <th className="p-2 text-right">Acciones</th>
                  </tr>
                </thead>
                <tbody>
                  {agrupados[inmId].estancias.map((est: any) => (
                    <tr key={est.id} className="border-t hover:bg-green-50">
                      <td className="p-2 font-mono text-gray-400">{est.id}</td>
                      <td className="p-2 font-bold text-gray-700">{est.nombre}</td>
                      <td className="p-2 text-green-700 font-semibold text-xs uppercase">{est.tipo_estancia_desc}</td>
                      <td className="p-2 text-right space-x-4">
                        <button onClick={() => { setEditingId(est.id); setForm({inmueble_id: est.inmueble_id.toString(), tipo_estancia_id: est.tipo_estancia_id.toString(), nombre: est.nombre}); }} className="text-blue-500 font-bold">Editar</button>
                        <button onClick={() => apiDelete(`/api/estancia/${est.id}`).then(load)} className="text-red-500">Borrar</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

--- ARCHIVO: src\components\HealthPanel.tsx ---
/**
 * ============================================================================
 * COMPONENTE: HealthPanel.tsx
 * ============================================================================
 * Descripción: Panel de control para verificar la salud de la conexión.
 * Sección: DIAGNÓSTICO - Verifica latencia y estado del Backend.
 * ============================================================================
 */
import React, { useState } from 'react';
import { apiGet } from '../api';

export default function HealthPanel() {
  const [status, setStatus] = useState<any>(null);

  const check = async () => {
    try {
      const res = await apiGet('/health');
      setStatus(res);
    } catch (e) {
      setStatus({ status: "Error de conexión" });
    }
  };

  return (
    <div className="alert alert-info mt-4">
      <h5>Estado del Servidor</h5>
      <button onClick={check} className="btn btn-primary btn-sm">Refrescar Estado</button>
      {status && (
        <pre className="mt-2 bg-dark text-white p-2 rounded">
          {JSON.stringify(status, null, 2)}
        </pre>
      )}
    </div>
  );
}

--- ARCHIVO: src\components\InmuebleForm.tsx ---
/**
 * ============================================================================
 * COMPONENTE: InmuebleForm.tsx
 * PROYECTO: PROPARCON Web Client
 * DESCRIPCIÓN: Gestión centralizada de activos inmobiliarios y catastro.
 * ============================================================================
 * ACTUALIZACIÓN REALIZADA:
 * ✅ ALINEACIÓN DE CAMPOS: Sincronizado con 'nombre_publico' y 'referencia_catastral'
 * según el esquema InmuebleCreate del backend.
 * ✅ FULL CRUD UI: Implementado soporte para Listar (GET), Crear (POST), 
 * Actualizar (PATCH) y Eliminar (DELETE).
 * ✅ MODO EDICIÓN: El formulario conmuta dinámicamente entre alta y edición.
 * ✅ NORMALIZACIÓN: Uso de apiPatch para actualizaciones parciales.
 * ============================================================================
 */

import React, { useEffect, useState } from 'react';
import { apiGet, apiPost, apiDelete, apiPatch } from '../api';

export default function InmuebleForm() {
  // --- SECCIÓN 1: ESTADO Y VARIABLES ---
  const [items, setItems] = useState<any[]>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);
  
  // Estado alineado con InmuebleCreate e InmuebleUpdate del backend
  const [form, setForm] = useState({ 
    tipo_inmueble_id: 1, 
    nombre_publico: '', 
    direccion_id: 1, 
    referencia_catastral: '' 
  });

  // --- SECCIÓN 2: CARGA DE DATOS (READ) ---
  const load = async () => {
    try {
      setLoading(true);
      // Llama al nuevo endpoint de listado global implementado en inmueble.py
      const data = await apiGet('/api/inmueble');
      setItems(Array.isArray(data) ? data : []);
    } catch (e) { 
      console.error("Error al cargar la cartera de inmuebles", e); 
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { load(); }, []);

  // --- SECCIÓN 3: GESTIÓN DE EDICIÓN ---
  const handleEdit = (item: any) => {
    setEditingId(item.id);
    // Cargamos los datos actuales en el formulario
    setForm({
      tipo_inmueble_id: item.tipo_inmueble_id || 1,
      nombre_publico: item.nombre_publico || '',
      direccion_id: item.direccion_id || 1,
      referencia_catastral: item.ref_catastral || '' // Viene del LEFT JOIN de la API
    });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  const cancelEdit = () => {
    setEditingId(null);
    setForm({ tipo_inmueble_id: 1, nombre_publico: '', direccion_id: 1, referencia_catastral: '' });
  };

  // --- SECCIÓN 4: ACCIONES DE PERSISTENCIA (CREATE / UPDATE) ---
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (editingId) {
        // Ejecuta PATCH alineado con actualizar_inmueble en el backend
        await apiPatch(`/api/inmueble/${editingId}`, form);
      } else {
        // Ejecuta POST alineado con crear_inmueble_completo en el backend
        await apiPost('/api/inmueble', form);
      }
      cancelEdit();
      load();
    } catch (e) { 
      alert("Error al procesar el inmueble. Verifique los datos técnicos."); 
    }
  };

  // --- SECCIÓN 5: RENDERIZADO DE INTERFAZ ---
  return (
    <div className="p-4 bg-white rounded shadow">
      <h2 className="text-xl font-bold mb-4 border-b">
        {editingId ? '🛠️ Editando Inmueble' : '🏠 Cartera de Inmuebles'}
      </h2>

      {/* Formulario de Inmueble */}
      <form onSubmit={handleSubmit} className="grid grid-cols-2 gap-4 mb-8 bg-gray-50 p-4 border rounded">
        <div className="flex flex-col">
          <label className="text-xs font-bold text-gray-500 uppercase">Nombre Público / Alias</label>
          <input 
            value={form.nombre_publico} 
            onChange={e => setForm({...form, nombre_publico: e.target.value})} 
            className="p-2 border rounded bg-white" 
            placeholder="Ej: Apartamento Centro"
            required 
          />
        </div>
        
        <div className="flex flex-col">
          <label className="text-xs font-bold text-gray-500 uppercase">Referencia Catastral</label>
          <input 
            value={form.referencia_catastral} 
            onChange={e => setForm({...form, referencia_catastral: e.target.value})} 
            className="p-2 border rounded bg-white" 
            placeholder="20 caracteres alfanuméricos"
          />
        </div>

        <div className="flex flex-col">
          <label className="text-xs font-bold text-gray-500 uppercase">ID Tipo Inmueble</label>
          <input 
            type="number"
            value={form.tipo_inmueble_id} 
            onChange={e => setForm({...form, tipo_inmueble_id: parseInt(e.target.value)})} 
            className="p-2 border rounded bg-white" 
            required
          />
        </div>

        <div className="flex flex-col">
          <label className="text-xs font-bold text-gray-500 uppercase">ID Dirección</label>
          <input 
            type="number"
            value={form.direccion_id} 
            onChange={e => setForm({...form, direccion_id: parseInt(e.target.value)})} 
            className="p-2 border rounded bg-white" 
            required
          />
        </div>

        <div className="col-span-2 flex gap-2 pt-2">
          <button 
            type="submit" 
            className={`flex-1 p-2 rounded text-white font-bold transition-colors ${editingId ? 'bg-orange-500 hover:bg-orange-600' : 'bg-blue-600 hover:bg-blue-700'}`}
          >
            {editingId ? 'Actualizar Inmueble' : 'Guardar Inmueble'}
          </button>
          {editingId && (
            <button 
              type="button" 
              onClick={cancelEdit} 
              className="px-4 p-2 bg-gray-300 rounded hover:bg-gray-400 transition-colors"
            >
              Cancelar
            </button>
          )}
        </div>
      </form>

      {/* Tabla de Resultados (Listado Global) */}
      <div className="overflow-x-auto">
        <table className="w-full text-left border-collapse">
          <thead>
            <tr className="bg-gray-100 text-xs uppercase text-gray-600">
              <th className="p-2 border">ID</th>
              <th className="p-2 border">Nombre Público</th>
              <th className="p-2 border">Ref. Catastral</th>
              <th className="p-2 border">Acciones</th>
            </tr>
          </thead>
          <tbody className="text-sm">
            {loading ? (
              <tr><td colSpan={4} className="p-4 text-center">Cargando activos...</td></tr>
            ) : items.map((i) => (
              <tr key={i.id} className="hover:bg-blue-50 transition-colors">
                <td className="p-2 border text-gray-500">{i.id}</td>
                <td className="p-2 border font-medium">{i.nombre_publico}</td>
                <td className="p-2 border font-mono text-xs">{i.ref_catastral || 'Sin asignar'}</td>
                <td className="p-2 border">
                  <div className="flex gap-4">
                    <button 
                      onClick={() => handleEdit(i)} 
                      className="text-blue-600 hover:text-blue-800 font-bold"
                    >
                      Editar
                    </button>
                    <button 
                      onClick={() => apiDelete(`/api/inmueble/${i.id}`).then(load)} 
                      className="text-red-600 hover:text-red-800"
                    >
                      Borrar
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      {!loading && items.length === 0 && (
        <p className="py-6 text-center text-gray-500 italic">No hay inmuebles registrados en la cartera.</p>
      )}
    </div>
  );
}

--- ARCHIVO: src\components\OfertaForm.tsx ---
/**
 * ============================================================================
 * COMPONENTE: OfertaForm.tsx
 * DISEÑO: Jerarquía Inmueble -> Ofertas con sangría y cabecera única.
 * ============================================================================
 * ACTUALIZACIÓN REALIZADA:
 * ✅ REINTEGRACIÓN CREATE/UPDATE: Formulario funcional en la parte superior.
 * ✅ DISEÑO JERÁRQUICO: Agrupación por Inmueble y sangría ml-12.
 * ✅ CABECERA ÚNICA: Solo una fila de etiquetas por cada inmueble.
 * ============================================================================
 */
import React, { useEffect, useState } from 'react';
import { apiGet, apiPost, apiDelete, apiPatch } from '../api';

export default function OfertaForm() {
  const [items, setItems] = useState<any[]>([]);
  const [estancias, setEstancias] = useState<any[]>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [form, setForm] = useState({
    estancia_id: '',
    renta_mensual: '',
    fecha_alta: new Date().toISOString().split('T')[0],
    estado_id: 1
  });

  const load = async () => {
    const [dOff, dEst] = await Promise.all([apiGet('/api/oferta'), apiGet('/api/estancia')]);
    setItems(Array.isArray(dOff) ? dOff : []);
    setEstancias(Array.isArray(dEst) ? dEst : []);
  };

  useEffect(() => { load(); }, []);

  const agrupados = items.reduce((acc: any, curr: any) => {
    const key = curr.inmueble_id;
    if (!acc[key]) acc[key] = { nombre: curr.inmueble_nombre, ofertas: [] };
    acc[key].ofertas.push(curr);
    return acc;
  }, {});

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const payload = {
      ...form,
      estancia_id: parseInt(form.estancia_id),
      renta_mensual: parseFloat(form.renta_mensual)
    };
    if (editingId) await apiPatch(`/api/oferta/${editingId}`, payload);
    else await apiPost('/api/oferta', payload);
    setEditingId(null);
    setForm({ estancia_id: '', renta_mensual: '', fecha_alta: new Date().toISOString().split('T')[0], estado_id: 1 });
    load();
  };

  const handleEdit = (o: any) => {
    setEditingId(o.id);
    setForm({
      estancia_id: o.estancia_id.toString(),
      renta_mensual: o.renta_mensual.toString(),
      fecha_alta: o.fecha_alta,
      estado_id: o.estado_id
    });
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  return (
    <div className="p-6 bg-white rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold mb-6 text-orange-900 border-b pb-2">
        {editingId ? '🛠️ Editar Oferta' : '📢 Publicar Oferta Comercial'}
      </h2>

      {/* Formulario de Registro/Edición */}
      <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-10 bg-orange-50 p-4 rounded-md border border-orange-200">
        <select value={form.estancia_id} onChange={e => setForm({...form, estancia_id: e.target.value})} className="p-2 border rounded" required disabled={!!editingId}>
          <option value="">Seleccione Estancia...</option>
          {estancias.map(est => (
            <option key={est.id} value={est.id}>{est.inmueble_nombre} - {est.nombre}</option>
          ))}
        </select>
        <input type="number" step="0.01" value={form.renta_mensual} onChange={e => setForm({...form, renta_mensual: e.target.value})} className="p-2 border rounded" placeholder="Renta Mensual (€)" required />
        <input type="date" value={form.fecha_alta} onChange={e => setForm({...form, fecha_alta: e.target.value})} className="p-2 border rounded" required />
        <button type="submit" className={`p-2 rounded text-white font-bold transition-colors ${editingId ? 'bg-orange-600' : 'bg-orange-800 hover:bg-orange-900'}`}>
          {editingId ? 'Actualizar' : 'Publicar'}
        </button>
      </form>

      {/* Listado Jerárquico con Sangría */}
      <div className="space-y-10">
        {Object.keys(agrupados).map(inmId => (
          <div key={inmId}>
            <div className="flex items-center bg-orange-900 p-3 rounded-t-lg text-white">
              <span className="text-lg font-bold">🏢 INMUEBLE: {agrupados[inmId].nombre}</span>
              <span className="ml-3 text-xs opacity-60">(ID: {inmId})</span>
            </div>

            <div className="ml-12 border-l border-b border-r rounded-b-lg overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-gray-100 text-[10px] uppercase text-gray-500">
                  <tr>
                    <th className="p-2 text-left">Estancia</th>
                    <th className="p-2 text-center">Renta Mensual</th>
                    <th className="p-2 text-center">Fecha Alta</th>
                    <th className="p-2 text-right">Acciones</th>
                  </tr>
                </thead>
                <tbody>
                  {agrupados[inmId].ofertas.map((o: any) => (
                    <tr key={o.id} className="border-t hover:bg-orange-50">
                      <td className="p-2 font-bold text-gray-700">{o.estancia_nombre}</td>
                      <td className="p-2 text-center font-bold text-orange-700">{o.renta_mensual} €</td>
                      <td className="p-2 text-center text-xs text-gray-500">{o.fecha_alta}</td>
                      <td className="p-2 text-right space-x-4">
                        <button onClick={() => handleEdit(o)} className="text-blue-600 font-bold hover:underline">Editar</button>
                        <button onClick={() => apiDelete(`/api/oferta/${o.id}`).then(load)} className="text-red-500 hover:underline">Borrar</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

--- ARCHIVO: src\components\PersonaForm.tsx ---
/**
 * ============================================================================
 * COMPONENTE: PersonaForm.tsx
 * PROYECTO: PROPARCON Web Client
 * ============================================================================
 * ACTUALIZACIÓN: 
 * ✅ Implementada funcionalidad de Actualización (UPDATE/PATCH).
 * ✅ Gestión de estado para conmutar entre Creación y Edición.
 * ✅ Alineación de nombres de campo con la API de Postman.
 * ============================================================================
 */
import React, { useEffect, useState } from 'react';
import { apiGet, apiPost, apiDelete, apiPatch } from '../api';

export default function PersonaForm() {
  const [items, setItems] = useState<any[]>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  
  const [form, setForm] = useState({ 
    doc_identidad: '', 
    nombre: '', 
    apellido1: '', 
    email_particular: '' 
  });

  const load = async () => {
    try {
      const data = await apiGet('/api/persona');
      setItems(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error("Error al cargar personas:", err);
    }
  };

  useEffect(() => { load(); }, []);

  // Prepara el formulario con los datos de la persona seleccionada
  const handleEdit = (persona: any) => {
    setEditingId(persona.id);
    setForm({
      doc_identidad: persona.doc_identidad,
      nombre: persona.nombre,
      apellido1: persona.apellido1,
      email_particular: persona.email_particular || ''
    });
    window.scrollTo(0, 0); // Sube al formulario
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (editingId) {
        // UPDATE: Enviamos PATCH a /api/persona/{id}
        await apiPatch(`/api/persona/${editingId}`, form);
      } else {
        // CREATE: Enviamos POST a /api/persona
        await apiPost('/api/persona', form);
      }
      
      // Limpiar y recargar
      setForm({ doc_identidad: '', nombre: '', apellido1: '', email_particular: '' });
      setEditingId(null);
      load();
    } catch (err) {
      alert("Error al procesar la solicitud");
    }
  };

  const cancelEdit = () => {
    setEditingId(null);
    setForm({ doc_identidad: '', nombre: '', apellido1: '', email_particular: '' });
  };

  return (
    <div className="p-4 bg-white rounded shadow">
      <h2 className="text-xl font-bold mb-4 border-b">
        {editingId ? 'Editar Persona' : 'Gestión de Personas'}
      </h2>

      <form onSubmit={handleSubmit} className="grid grid-cols-2 gap-4 mb-8 bg-gray-50 p-4 rounded border">
        <div className="flex flex-col">
          <label className="text-xs font-semibold text-gray-500">Documento</label>
          <input 
            value={form.doc_identidad}
            onChange={e => setForm({...form, doc_identidad: e.target.value})}
            className="p-2 border rounded bg-white"
            disabled={editingId !== null} // Normalmente el DNI no se cambia
          />
        </div>
        <div className="flex flex-col">
          <label className="text-xs font-semibold text-gray-500">Nombre</label>
          <input 
            value={form.nombre}
            onChange={e => setForm({...form, nombre: e.target.value})}
            className="p-2 border rounded bg-white"
            required
          />
        </div>
        <div className="flex flex-col">
          <label className="text-xs font-semibold text-gray-500">Apellido</label>
          <input 
            value={form.apellido1}
            onChange={e => setForm({...form, apellido1: e.target.value})}
            className="p-2 border rounded bg-white"
            required
          />
        </div>
        <div className="flex flex-col">
          <label className="text-xs font-semibold text-gray-500">Email</label>
          <input 
            type="email"
            value={form.email_particular}
            onChange={e => setForm({...form, email_particular: e.target.value})}
            className="p-2 border rounded bg-white"
          />
        </div>
        
        <div className="col-span-2 flex gap-2">
          <button type="submit" className={`flex-1 p-2 rounded text-white ${editingId ? 'bg-orange-500' : 'bg-blue-600'}`}>
            {editingId ? 'Actualizar Datos' : 'Guardar Persona'}
          </button>
          {editingId && (
            <button type="button" onClick={cancelEdit} className="p-2 bg-gray-300 rounded">
              Cancelar
            </button>
          )}
        </div>
      </form>

      <table className="w-full text-left border-collapse">
        <thead>
          <tr className="bg-gray-100 text-sm">
            <th className="p-2 border">Nombre</th>
            <th className="p-2 border">Documento</th>
            <th className="p-2 border">Acciones</th>
          </tr>
        </thead>
        <tbody className="text-sm">
          {items.map((p) => (
            <tr key={p.id} className="hover:bg-blue-50">
              <td className="p-2 border font-medium">{p.nombre} {p.apellido1}</td>
              <td className="p-2 border text-gray-600">{p.doc_identidad}</td>
              <td className="p-2 border">
                <div className="flex gap-3">
                  <button onClick={() => handleEdit(p)} className="text-blue-600 hover:text-blue-800 font-semibold">
                    Editar
                  </button>
                  <button onClick={() => apiDelete(`/api/persona/${p.id}`).then(load)} className="text-red-600 hover:text-red-800">
                    Borrar
                  </button>
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

--- ARCHIVO: src\components\PropiedadForm.tsx ---
/**
 * ============================================================================
 * COMPONENTE: PropiedadForm.tsx
 * DISEÑO: Jerarquía Inmueble -> Propietarios con sangría y cabecera única.
 * ============================================================================
 */
import React, { useEffect, useState } from 'react';
import { apiGet, apiPost, apiDelete, apiPatch } from '../api';

export default function PropiedadForm() {
  const [items, setItems] = useState<any[]>([]);
  const [inmuebles, setInmuebles] = useState<any[]>([]);
  const [personas, setPersonas] = useState<any[]>([]);
  const [editingId, setEditingId] = useState<number | null>(null);
  const [form, setForm] = useState({ inmueble_id: '', persona_id: '', tipo_derecho_id: '1', porcentaje: '100' });

  const load = async () => {
    const [dProp, dInm, dPers] = await Promise.all([
      apiGet('/api/propiedad'), apiGet('/api/inmueble'), apiGet('/api/persona')
    ]);
    setItems(Array.isArray(dProp) ? dProp : []);
    setInmuebles(Array.isArray(dInm) ? dInm : []);
    setPersonas(Array.isArray(dPers) ? dPers : []);
  };

  useEffect(() => { load(); }, []);

  const agrupados = items.reduce((acc: any, curr: any) => {
    const key = curr.inmueble_id;
    if (!acc[key]) acc[key] = { nombre: curr.inmueble_nombre, propietarios: [] };
    acc[key].propietarios.push(curr);
    return acc;
  }, {});

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const payload = { 
      inmueble_id: parseInt(form.inmueble_id), persona_id: parseInt(form.persona_id), 
      tipo_derecho_id: parseInt(form.tipo_derecho_id), porcentaje: parseFloat(form.porcentaje) 
    };
    if (editingId) await apiPatch(`/api/propiedad/${editingId}`, payload);
    else await apiPost('/api/propiedad', payload);
    setEditingId(null);
    setForm({ inmueble_id: '', persona_id: '', tipo_derecho_id: '1', porcentaje: '100' });
    load();
  };

  return (
    <div className="p-6 bg-white rounded-lg shadow">
      <h2 className="text-2xl font-bold mb-6 text-blue-900 border-b pb-2">Gestión de Propiedades</h2>

      <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-10 bg-blue-50 p-4 rounded-md border">
        <select value={form.inmueble_id} onChange={e => setForm({...form, inmueble_id: e.target.value})} className="p-2 border rounded" required disabled={!!editingId}>
          <option value="">Inmueble...</option>
          {inmuebles.map(i => <option key={i.id} value={i.id}>{i.nombre_publico}</option>)}
        </select>
        <select value={form.persona_id} onChange={e => setForm({...form, persona_id: e.target.value})} className="p-2 border rounded" required>
          <option value="">Titular...</option>
          {personas.map(p => <option key={p.id} value={p.id}>{p.nombre} {p.apellido1}</option>)}
        </select>
        <input type="number" step="0.01" value={form.porcentaje} onChange={e => setForm({...form, porcentaje: e.target.value})} className="p-2 border rounded" placeholder="%" required />
        <button type="submit" className={`p-2 rounded text-white font-bold ${editingId ? 'bg-orange-500' : 'bg-blue-600'}`}>{editingId ? 'Actualizar' : 'Asignar'}</button>
      </form>

      <div className="space-y-8">
        {Object.keys(agrupados).map(inmId => (
          <div key={inmId}>
            <div className="flex items-center bg-blue-900 p-3 rounded-t-lg text-white">
              <span className="text-lg font-bold">🏢 INMUEBLE: {agrupados[inmId].nombre}</span>
              <span className="ml-3 text-xs opacity-60">(ID: {inmId})</span>
            </div>
            <div className="ml-12 border-l border-b border-r rounded-b-lg overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-gray-100 text-[10px] uppercase text-gray-500">
                  <tr>
                    <th className="p-2 text-left">Titular / Doc.</th>
                    <th className="p-2 text-center">Derecho</th>
                    <th className="p-2 text-center">% Participación</th>
                    <th className="p-2 text-right">Acciones</th>
                  </tr>
                </thead>
                <tbody>
                  {agrupados[inmId].propietarios.map((p: any) => (
                    <tr key={p.id} className="border-t hover:bg-blue-50">
                      <td className="p-2">
                        <div className="font-bold">{p.titular_nombre}</div>
                        <div className="text-[10px] text-gray-400 font-mono">{p.titular_doc}</div>
                      </td>
                      <td className="p-2 text-center text-xs font-semibold">{p.derecho_desc}</td>
                      <td className="p-2 text-center font-bold text-blue-700">{p.porcentaje}%</td>
                      <td className="p-2 text-right space-x-4">
                        <button onClick={() => { setEditingId(p.id); setForm({inmueble_id: p.inmueble_id.toString(), persona_id: p.persona_id.toString(), porcentaje: p.porcentaje.toString(), tipo_derecho_id: p.tipo_derecho_id.toString()}); }} className="text-blue-500 font-bold">Editar</button>
                        <button onClick={() => apiDelete(`/api/propiedad/${p.id}`).then(load)} className="text-red-500">Borrar</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

--- ARCHIVO: src\pages\CatalogosPage.tsx ---
/**
 * =============================================================================
 * CatalogosPage.tsx — Administración CRUD genérica de Catálogos (CAT)
 * =============================================================================
 * Funcionalidad:
 *  - Lista catálogo (GET)
 *  - Crea registro (POST)
 *  - Edita registro (PATCH)
 *  - Borra registro (DELETE)
 *
 * Alineación con BD/API PROPARCON (DDL):
 *  - Columnas: id, codigo, descripcion
 *  - El frontend debe usar "descripcion" (no "nombre").
 * =============================================================================
 */

import { useEffect, useMemo, useState } from "react";
import {
  listarCatalogo,
  crearCatalogo,
  actualizarCatalogo,
  borrarCatalogo,
} from "../services/catalogosService";
import type { CatalogoItem } from "../types/catalogos";

const CATALOGOS = ["estado_oferta", "estado_contrato", "tipo_inmueble", "tipo_via"];

export default function CatalogosPage() {
  const [catalogo, setCatalogo] = useState(CATALOGOS[0]);
  const [items, setItems] = useState<CatalogoItem[]>([]);

  const [descripcion, setDescripcion] = useState("");
  const [codigo, setCodigo] = useState("");

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Edición inline
  const [editingId, setEditingId] = useState<number | null>(null);
  const [editDescripcion, setEditDescripcion] = useState("");
  const [editCodigo, setEditCodigo] = useState("");

  const canSubmitCreate = useMemo(
    () => descripcion.trim().length > 0 && codigo.trim().length > 0,
    [descripcion, codigo]
  );

  async function cargar() {
    setLoading(true);
    setError(null);
    try {
      const data = await listarCatalogo(catalogo);
      setItems(data);
    } catch (e: any) {
      setError(e?.message || "Error cargando catálogo");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    cargar();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [catalogo]);

  async function crear() {
    if (!canSubmitCreate || loading) return;

    const c = codigo.trim();
    const d = descripcion.trim();

    setLoading(true);
    setError(null);
    try {
      await crearCatalogo(catalogo, { codigo: c, descripcion: d });
      setDescripcion("");
      setCodigo("");
      await cargar();
    } catch (e: any) {
      setError(e?.message || "Error creando registro");
    } finally {
      setLoading(false);
    }
  }

  function empezarEdicion(it: CatalogoItem) {
    setEditingId(it.id);
    setEditDescripcion(it.descripcion ?? "");
    setEditCodigo(it.codigo ?? "");
    setError(null);
  }

  function cancelarEdicion() {
    setEditingId(null);
    setEditDescripcion("");
    setEditCodigo("");
  }

  async function guardarEdicion(id: number) {
    if (loading) return;

    const d = editDescripcion.trim();
    const c = editCodigo.trim();

    if (!c) {
      setError("El código no puede estar vacío.");
      return;
    }
    if (!d) {
      setError("La descripción no puede estar vacía.");
      return;
    }

    setLoading(true);
    setError(null);
    try {
      await actualizarCatalogo(catalogo, id, { codigo: c, descripcion: d });
      cancelarEdicion();
      await cargar();
    } catch (e: any) {
      setError(e?.message || "Error actualizando registro");
    } finally {
      setLoading(false);
    }
  }

  async function borrar(id: number) {
    if (loading) return;
    if (!confirm("¿Eliminar registro?")) return;

    setLoading(true);
    setError(null);
    try {
      await borrarCatalogo(catalogo, id);
      await cargar();
    } catch (e: any) {
      setError(e?.message || "Error borrando registro");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-4 space-y-4">
      <div>
        <h1 className="text-xl font-bold">Administración · Catálogos</h1>
        <p className="text-sm text-gray-600">
          Catálogo activo: <span className="font-mono">{catalogo}</span>
        </p>
      </div>

      <div className="flex flex-wrap items-center gap-2">
        <select
          className="border p-2"
          value={catalogo}
          onChange={(e) => {
            cancelarEdicion();
            setCatalogo(e.target.value);
          }}
          disabled={loading}
        >
          {CATALOGOS.map((c) => (
            <option key={c} value={c}>
              {c}
            </option>
          ))}
        </select>

        {loading && <span className="text-sm text-gray-600">Cargando…</span>}
        {error && <span className="text-sm text-red-700">{error}</span>}
      </div>

      <div className="flex flex-wrap gap-2">
        <input
          className="border p-2"
          placeholder="Código"
          value={codigo}
          onChange={(e) => setCodigo(e.target.value)}
          disabled={loading}
        />
        <input
          className="border p-2 flex-1 min-w-[240px]"
          placeholder="Descripción"
          value={descripcion}
          onChange={(e) => setDescripcion(e.target.value)}
          disabled={loading}
        />
        <button
          className="bg-blue-600 text-white px-4 py-2 disabled:opacity-50"
          onClick={crear}
          disabled={!canSubmitCreate || loading}
        >
          Añadir
        </button>
      </div>

      <table className="w-full border bg-white">
        <thead>
          <tr className="bg-gray-100">
            <th className="border p-2 text-left">ID</th>
            <th className="border p-2 text-left">Código</th>
            <th className="border p-2 text-left">Descripción</th>
            <th className="border p-2 text-left">Acciones</th>
          </tr>
        </thead>

        <tbody>
          {items.map((it) => {
            const isEditing = editingId === it.id;

            return (
              <tr key={it.id}>
                <td className="border p-2">{it.id}</td>

                <td className="border p-2">
                  {isEditing ? (
                    <input
                      className="border p-2 w-full"
                      value={editCodigo}
                      onChange={(e) => setEditCodigo(e.target.value)}
                      disabled={loading}
                    />
                  ) : (
                    it.codigo ?? ""
                  )}
                </td>

                <td className="border p-2">
                  {isEditing ? (
                    <input
                      className="border p-2 w-full"
                      value={editDescripcion}
                      onChange={(e) => setEditDescripcion(e.target.value)}
                      disabled={loading}
                    />
                  ) : (
                    it.descripcion ?? ""
                  )}
                </td>

                <td className="border p-2">
                  <div className="flex gap-2">
                    {!isEditing ? (
                      <>
                        <button
                          className="text-blue-700"
                          onClick={() => empezarEdicion(it)}
                          disabled={loading}
                        >
                          Editar
                        </button>
                        <button
                          className="text-red-700"
                          onClick={() => borrar(it.id)}
                          disabled={loading}
                        >
                          Borrar
                        </button>
                      </>
                    ) : (
                      <>
                        <button
                          className="text-green-700"
                          onClick={() => guardarEdicion(it.id)}
                          disabled={loading}
                        >
                          Guardar
                        </button>
                        <button
                          className="text-gray-700"
                          onClick={cancelarEdicion}
                          disabled={loading}
                        >
                          Cancelar
                        </button>
                      </>
                    )}
                  </div>
                </td>
              </tr>
            );
          })}

          {!loading && items.length === 0 && (
            <tr>
              <td className="border p-2 text-gray-600" colSpan={4}>
                Sin registros.
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
}



--- ARCHIVO: src\services\catalogosService.ts ---
/**
 * -----------------------------------------------------------------------------
 * catalogosService.ts
 * -----------------------------------------------------------------------------
 * Objetivo:
 *  - Consumir la API de Catálogos usando apiGet/apiPost/apiPatch/apiDelete.
 *  - Normalizar la respuesta a un tipo único de UI (CatalogoItem).
 *
 * Problema resuelto en esta versión:
 *  - Tu apiGet() acepta SOLO 1 argumento (url).
 *  - Por tanto, NO podemos hacer apiGet(url, { params: ... }).
 *  - Construimos el querystring manualmente en la URL.
 *
 * Compatibilidad UI/API:
 *  - En BD/API muchas tablas usan { codigo, descripcion }.
 *  - En UI se venía usando { nombre, codigo }.
 *  - Este servicio mapea:
 *      - descripcion -> nombre (para UI)
 *      - y SIEMPRE rellena descripcion (para TypeScript)
 * -----------------------------------------------------------------------------
 */

import { apiDelete, apiGet, apiPatch, apiPost } from "../api";
import type { CatalogoItem, CatalogoKey } from "../types/catalogos";

// -----------------------------------------------------------------------------
// Tipos internos (respuesta estándar de API para catálogos)
// -----------------------------------------------------------------------------
type ApiCatalogoRow = {
  id: number;
  codigo: string | null;
  descripcion: string;

  // Extras opcionales
  activo?: boolean | number | null;

  // Jerárquicos
  pais_id?: number;

  // Especial: tipo_estancia
  alquilable?: boolean;
  es_raiz?: boolean;
};

// -----------------------------------------------------------------------------
// Helper: construir URL con querystring (porque apiGet solo acepta 1 argumento)
// -----------------------------------------------------------------------------
function withQuery(url: string, params?: Record<string, string | number | boolean | null | undefined>): string {
  if (!params) return url;

  const qs = new URLSearchParams();
  for (const [k, v] of Object.entries(params)) {
    if (v === undefined || v === null) continue;
    qs.set(k, String(v));
  }

  const query = qs.toString();
  if (!query) return url;

  return url.includes("?") ? `${url}&${query}` : `${url}?${query}`;
}

// -----------------------------------------------------------------------------
// Helper: API -> UI (normalización)
// -----------------------------------------------------------------------------
function mapApiRowToUi(row: ApiCatalogoRow): CatalogoItem {
  /**
   * IMPORTANTE:
   * - Tu CatalogoItem (según el error anterior) exige `descripcion`.
   * - Para no romper UI antigua, también dejamos `nombre` como alias.
   */
  return {
    id: row.id,
    codigo: row.codigo ?? null,

    // Campo requerido por el tipo
    descripcion: row.descripcion,

    // Alias para UI antigua (si tu tipo lo permite; si no lo permite, bórralo y adapta la UI)
    nombre: row.descripcion,

    // Extras opcionales (si tu tipo los define)
    activo: row.activo ?? null,
    pais_id: row.pais_id,
    alquilable: row.alquilable,
    es_raiz: row.es_raiz,
  } as unknown as CatalogoItem;
}

// -----------------------------------------------------------------------------
// Helper: UI -> API (payload)
// -----------------------------------------------------------------------------
function buildApiPayload(input: {
  nombre?: string;
  descripcion?: string;
  codigo?: string | null;
  pais_id?: number;
  activo?: boolean | number | null;
  alquilable?: boolean;
  es_raiz?: boolean;
}): Record<string, unknown> {
  const descripcion = (input.descripcion ?? input.nombre ?? "").trim();

  const payload: Record<string, unknown> = {
    codigo: input.codigo ?? null,
    descripcion,
  };

  // extras
  if (typeof input.pais_id === "number") payload.pais_id = input.pais_id;
  if (input.activo !== undefined) payload.activo = input.activo;
  if (input.alquilable !== undefined) payload.alquilable = input.alquilable;
  if (input.es_raiz !== undefined) payload.es_raiz = input.es_raiz;

  return payload;
}

// -----------------------------------------------------------------------------
// API pública: LISTAR
// -----------------------------------------------------------------------------
export async function listarCatalogo(
  catalogo: CatalogoKey,
  opts?: { pais_id?: number }
): Promise<CatalogoItem[]> {
  /**
   * Regla de negocio:
   * - provincia SIEMPRE filtrado por pais_id.
   * - si no hay país seleccionado, devolvemos [] para no romper la UI.
   */
  if (catalogo === "provincia" && typeof opts?.pais_id !== "number") {
    return [];
  }

  const urlBase = `/api/catalogos/${catalogo}`;

  // Si hay filtros (ej: provincia)
  const url = catalogo === "provincia"
    ? withQuery(urlBase, { pais_id: opts?.pais_id })
    : urlBase;

  const rows = await apiGet<ApiCatalogoRow[]>(url);
  return rows.map(mapApiRowToUi);
}

// -----------------------------------------------------------------------------
// API pública: CREAR
// -----------------------------------------------------------------------------
export async function crearCatalogo(
  catalogo: CatalogoKey,
  data: { nombre: string; codigo?: string | null; pais_id?: number }
): Promise<CatalogoItem> {
  const payload = buildApiPayload({
    nombre: data.nombre,
    codigo: data.codigo ?? null,
    pais_id: data.pais_id,
  });

  const created = await apiPost<ApiCatalogoRow>(`/api/catalogos/${catalogo}`, payload);
  return mapApiRowToUi(created);
}

// -----------------------------------------------------------------------------
// API pública: ACTUALIZAR
// -----------------------------------------------------------------------------
export async function actualizarCatalogo(
  catalogo: CatalogoKey,
  id: number,
  data: { nombre?: string; codigo?: string | null; pais_id?: number }
): Promise<CatalogoItem> {
  const payload = buildApiPayload({
    nombre: data.nombre,
    codigo: data.codigo ?? null,
    pais_id: data.pais_id,
  });

  const updated = await apiPatch<ApiCatalogoRow>(`/api/catalogos/${catalogo}/${id}`, payload);
  return mapApiRowToUi(updated);
}

// -----------------------------------------------------------------------------
// API pública: BORRAR
// -----------------------------------------------------------------------------
export async function borrarCatalogo(
  catalogo: CatalogoKey,
  id: number,
  opts?: { pais_id?: number }
): Promise<void> {
  /**
   * Regla:
   * - provincia delete requiere pais_id (según la API que te propuse).
   * - lo pasamos en querystring.
   */
  const base = `/api/catalogos/${catalogo}/${id}`;
  const url =
    catalogo === "provincia"
      ? withQuery(base, { pais_id: opts?.pais_id })
      : base;

  await apiDelete(url);
}


--- ARCHIVO: src\types\catalogos.ts ---
// src/types/catalogos.ts
// =============================================================================
// Tipos para Catálogos (PROPARCON Web)
// =============================================================================
// BD (DDL): id, codigo, descripcion
// UI legacy: nombre
//
// Estrategia:
// - CatalogoItem soporta BOTH: `descripcion` (real) y `nombre` (legacy UI)
// - Recomendación: en UI usar `getCatalogoLabel(it)` y en payloads enviar `descripcion`
// =============================================================================

export type CatalogoKey =
  | "estado_oferta"
  | "estado_contrato"
  | "tipo_inmueble"
  | "tipo_via"
  // si luego amplías, añádelos aquí:
  | "pais"
  | "rol"
  | "tipo_avaliador"
  | "tipo_contrato"
  | "tipo_derecho_propiedad"
  | "tipo_estancia"
  | "tipo_ingreso"
  | "provincia";

export interface CatalogoItem {
  id: number;

  // DDL: codigo NOT NULL en casi todos; en UI permitimos null/"" para catálogos “simples”
  codigo: string | null;

  // DDL: descripcion NOT NULL
  descripcion: string;

  // Legacy/UI: algunas pantallas usan `nombre`
  // (lo mantenemos opcional para compatibilidad mientras migras el front)
  nombre?: string | null;
}

export interface CatalogoCreatePayload {
  // Preferido (DDL)
  descripcion: string;

  // opcional según catálogo
  codigo?: string | null;

  // Legacy
  nombre?: string;
}

export interface CatalogoUpdatePayload {
  descripcion?: string;
  codigo?: string | null;

  // Legacy
  nombre?: string;
}

// ----------------------------------------------------------------------------
// Helpers: normalización UI
// ----------------------------------------------------------------------------

/**
 * Devuelve el “texto” del catálogo para mostrar en UI,
 * priorizando `descripcion` y usando `nombre` como fallback.
 */
export function getCatalogoLabel(it: Pick<CatalogoItem, "descripcion" | "nombre">): string {
  const v = (it.descripcion ?? it.nombre ?? "").toString().trim();
  return v.length ? v : "(sin descripción)";
}

/**
 * Convierte un payload legacy {nombre} a {descripcion} para enviar a API.
 */
export function normalizeCatalogoPayload<T extends { nombre?: string; descripcion?: string }>(
  payload: T
): Omit<T, "nombre"> & { descripcion: string } {
  const descripcion = (payload.descripcion ?? payload.nombre ?? "").toString().trim();
  return {
    ...(payload as any),
    descripcion,
  };
}
